//
// $Id: dataset_skel.hh,v 1.3 2007-04-21 09:03:14 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.
//          Do not edit this file.
//
//  gslmm::statistic@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_statistic_dataset@name@
#define GSLMM_statistic_dataset@name@
#line 29 "dataset_skel.hh"
#ifndef GSLMM_statistic_base
# include <gslmm/statistic/statistic_base.hh>
#endif
#ifndef __GSL_STATISTICS_H__
# include <gsl/gsl_statistics.h>
#endif
#ifndef __VECTOR__
# include <vector>
#endif

#include <algorithm>  // sort

/** @file   statistic/dataset@name@.hh
    @author Christian Holm
    @date   Wed Mar 12 14:11:20 2003
    @brief  statistic class for @c @type@ */

namespace gslmm 
{
  
  /** @brief Class template specialisation for @c @type@.
      This class template specialisation represents a data set where
      each entry is of type @type@.  One creates a data set like 
      @code 
      gslmm::dataset<@code@> d;
      @endcode 
      after which one can add data points to @c d using the @c
      push_back member function. 
      @code 
      d.push_back(1);
      @endcode 
      At any given point, one can ask for various moments of the data
      set, like the mean, standard deviation, skew, and so on.  If the
      data has weights, one should use the derived class
      weighted_dataset instead. 
      @ingroup statistic
   */
  template <>
  class dataset<@type@ >
  {
  public:
    typedef @type@ data_type;
    typedef std::vector<@type@ > container_type;
    typedef @ftype@  return_type;
    
    /** Constructor, that initialises the data to the array @a d 
	@param d Initial data  */
    dataset(const container_type& d);
    /** Constructor that makes an empty sample. 
	@param n size of data set */
    dataset(size_t n=0) : _data(n) {}
    /** Destructor */
    virtual ~dataset() {}

    /** push another element onto the data set 
	@param d Data to push onto the set */
    virtual void push_back(data_type& d) { _data.push_back(d); }
    /** @return the number elements in the set */
    size_t size() const { return _data.size(); }
    /** Access individual elements 
	@param i index  */ 
    data_type& operator[](size_t i) { return _data[i]; }
    /** Access individual elements 
	@param i index  */ 
    const data_type& operator[](size_t i) const { return _data[i]; }
    /** @return the data array */
    container_type& data() { return _data; }
    /** @return the data array */
    const container_type& data() const { return _data; }

    /** Calculate and return the sample mean: 
	@f[
	\hat\mu = (1/N) \sum x_i
	@f]
	where @f$ x_i@f$ are the elements of the dataset of size 
	@f$ N@f$.  For samples drawn from a Gaussian distribution the
	variance of @f$ \hat\mu@f$ is @f$ \sigma^2 / N@f$
	@return @f$\hat\mu@f$ */
    virtual return_type mean() const;
    
    /** This member function returns the estimated, or sample,
	variance of the dataset of length @f$ N@f$.  The estimated 
	variance is denoted by @f$ \hat\sigma^2@f$ and is defined by,  
	@f[
	  \hat\sigma^2 = (1/(N-1)) \sum (x_i - \hat\mu)^2
	@f]
	where @f$ x_i@f$ are the elements of the dataset.  Note
	that the normalization factor of @f$ 1/(N-1)@f$ results from
	the derivation of @f$ \hat\sigma^2@f$ as an unbiased estimator
	of the population variance @f$ \sigma^2@f$.  For samples drawn
	from a Gaussian distribution the variance of @f$
	\hat\sigma^2@f$ itself is @f$ 2 \sigma^4 / N@f$. 
	@return @f$\hat\sigma^2@f$ */
    virtual return_type variance() const;
    
    /** This member function returns the sample variance of the
	dataset relative to the given value of @a mean.  The function
	is computed with @f$ \hat\mu@f$ replaced by the value of @a
	mean that you supply, 
	@f[
          \hat\sigma^2 = A \sum (x_i - mean)^2
	@f]
	where @f$ A=(1/(N-1))@f$ is the mean is computed from the
	sample (@a apriori is @c false), or @f$ A=(1/N)@f$ if the mean
	of the underlying distribution is known @e a @e priori (@a
	apriori is @c true).
	@param mean the given mean
	@param apriori If true, the mean is assumed to be known @e a
	@e priori and the normalisation is @f$ A=(1/N)@f$, otherwise
	the mean is taken to be calculated and the normalisation @f$
	A=(1/(N-1))@f$ is used/
	@return @f$\hat\sigma^2@f$ */
    virtual return_type variance(const return_type& mean, 
			       bool apriori=false) const; 

    /** The standard deviation is defined as the square root of the
	variance.  This member function return the square root of the 
	corresponding variance member functions above. 
	@return @f$\sqrt{\hat\sigma^2} @f$ */
    virtual return_type standard_deviation() const;
    
    /** The standard deviation is defined as the square root of the
	variance.  This member function return the square root of the 
	corresponding variance member functions above. 
	@param mean the given mean
	@param apriori If true, the mean is assumed to be known @e a
	@e priori and the normalisation is @f$ A=(1/N)@f$, otherwise
	the mean is taken to be calculated and the normalisation @f$
	A=(1/(N-1))@f$ is used/
	@return @f$\sqrt{\hat\sigma^2} @f$ */
    virtual return_type standard_deviation(const return_type& mean, 
					 bool apriori=false) const;
    
    /** This member function computes the absolute deviation from the
	mean of the dataset of length @f$ N@f$.  The absolute eviation
	from the mean is defined as, 
	@f[
          absdev  = (1/N) \sum |x_i - \hat\mu|
	@f]
	where @f$ x_i@f$ are the elements of the dataset.  The
	absolute deviation from the mean provides a more robust
	measure of the width of a distribution than the variance.
	@return @f$ absdev @f$ */
    virtual return_type absolute_deviation() const;
    
    /** This member function computes the absolute deviation from the
	mean of the dataset of length @f$ N@f$.  The absolute eviation
	from the mean is defined as, 
	@f[
          absdev  = (1/N) \sum |x_i - mean|
	@f]
	where @f$ x_i@f$ are the elements of the dataset.  The
	absolute deviation from the mean provides a more robust
	measure of the width of a distribution than the variance.
	@param mean the given mean
	@return @f$ absdev @f$ */
    virtual return_type absolute_deviation(const return_type& mean) const;

    /** This function computes the skewness of a dataset of length @f$
	N @f$.  The skewness is defined as,
	@f[
          skew = (1/N) \sum ((x_i - \hat\mu)/\hat\sigma)^3
        @f]
	where @f$ x_i@f$ are the elements of the dataset.  The
	skewness measures the asymmetry of the tails of a
	distribution. 
	@return @f$ skew@f$ */
    virtual return_type skew() const;
    /** This function computes the skewness of a dataset of length @f$
	N @f$ with pre-computed mean @a mean and standard deviation @a
	sd.  The skewness is defined as, 
	@f[
          skew = (1/N) \sum ((x_i - mean)/sd)^3
        @f]
	where @f$ x_i@f$ are the elements of the dataset.  The
	skewness measures the asymmetry of the tails of a
	distribution. 
	@param mean Pre-calculated mean
	@param sd Pre-calculated standard deviation
	@return @f$ skew@f$ */
    virtual return_type skew(const return_type& mean, const return_type& sd) const;

    /** This function computes the kurtosisness of a dataset of length @f$
	N @f$.  The kurtosis is defined as,
	@f[
          kurtosis = ((1/N) \sum ((x_i - \hat\mu)/\hat\sigma)^4)  - 3
        @f]
	where @f$ x_i@f$ are the elements of the dataset.  The
	kurtosis measures how sharply peaked a distribution is,
	relative to its width.  The kurtosis is normalized to zero for
	a  Gaussian distribution.
	@return @f$ kurtosis@f$ */
    virtual return_type kurtosis() const;
    /** This function computes the kurtosisness of a dataset of length @f$
	N @f$ with pre-computed mean @a mean and standard deviation @a
	sd.  The kurtosis is defined as, 
	@f[
          kurtosis = ((1/N) \sum ((x_i - mean)/sd)^4) - 3
        @f]
	where @f$ x_i@f$ are the elements of the dataset.  The
	kurtosis measures how sharply peaked a distribution is,
	relative to its width.  The kurtosis is normalized to zero for
	a  Gaussian distribution.
	@param mean Pre-calculated mean
	@param sd Pre-calculated standard deviation
	@return @f$ kurtosis@f$ */
    virtual return_type kurtosis(const return_type& mean, 
			       const return_type& sd) const;
    

    /** This function computes the lag-1 autocorrelation of the
	dataset.
	@f[
          a_1 = \frac{\sum_{i = 1}^{n} (x_{i} - \hat\mu) (x_{i-1} - \hat\mu)}
                 {\sum_{i = 1}^{n} (x_{i} - \hat\mu) (x_{i} - \hat\mu)}
	@f]
	@return @f$ a_1@f$ */
    return_type auto_correlation() const;

    /** This function computes the lag-1 autocorrelation with a
	pre-computed mean @a mean of the dataset.
	@f[
          a_1 = \frac{\sum_{i = 1}^{n} (x_{i} - mean) (x_{i-1} - mean)}
                 {\sum_{i = 1}^{n} (x_{i} - mean) (x_{i} - mean)}
	@f]
	@param mean pre-computed mean
	@return @f$ a_1@f$ */
    return_type auto_correlation(const return_type& mean) const;
    
    /** This member function computes the covariance of this datasets
	 and the dataset @a data2 which must both be of the same
	 length @f$ N@f$.
	 @f[
          covar = (1/(N - 1)) \sum_{i = 1}^{N} (x_i - \hat x) (y_i - \hat y)
         @f]
	 @param data2 other dataset 
	 @return @f$ covar@f$ */
    return_type covariance(const container_type& data2);

    /** This member function computes the covariance of this datasets
	 and the dataset @a data2 which must both be of the same
	 length @f$ N@f$.
	 @f[
          covar = (1/(N - 1)) \sum_{i = 1}^{N} (x_i - \hat x) (y_i - \hat y)
         @f]
	 @param data2 other dataset 
	 @return @f$ covar@f$ */
    return_type covariance(const dataset<@type@ >& data2);

    /** This member function computes the covariance of this datasets
	 with pre-computed mean @a mean, and the dataset @a data2
	 with pre-computed mean @a mean2 which must both be of the same 
	 length @f$ N@f$.
	 @f[
          covar = (1/(N - 1)) \sum_{i = 1}^{N} (x_i - mean) (y_i - mean2)
         @f]
	 @param data2 other dataset 
	 @param mean Mean of this data set 
	 @param mean2 Mean of other data set
	 @return @f$ covar@f$ */
    return_type covariance(const container_type& data2, 
			 const return_type& mean, const return_type& mean2);

    /** This member function computes the covariance of this datasets
	 with pre-computed mean @a mean, and the dataset @a data2
	 with pre-computed mean @a mean2 which must both be of the same 
	 length @f$ N@f$.
	 @f[
          covar = (1/(N - 1)) \sum_{i = 1}^{N} (x_i - mean) (y_i - mean2)
         @f]
	 @param data2 other dataset 
	 @param mean Mean of this data set 
	 @param mean2 Mean of other data set
	 @return @f$ covar@f$ */
    return_type covariance(const dataset<@type@ >& data2, 
			 const return_type& mean, const return_type& mean2);
    

    /** calculate the pooled-variance  
	@f[
	  \frac{(N - 1) * \sigma^2 + (N_2 - 1) * \sigma^2_2}{N + N_2 - 2}
	@f]
	where @f$\sigma^2@f$ is the variance this dataset, and
	@f$\sigma_2^2@f$ is the variance of the other dataset @a data2 
	@return the pooled variance */
    return_type pooled_variance(const dataset<@type@ >& data2);
    /** calculate the pooled-variance  
	@f[
	  \frac{(N - 1) * \sigma^2 + (N_2 - 1) * \sigma^2_2}{N + N_2 - 2}
	@f]
	where @f$\sigma^2@f$ is the variance this dataset, and
	@f$\sigma_2^2@f$ is the variance of the other dataset @a data2 
	@return the pooled variance */
    return_type pooled_variance(const container_type& data2);
    

    /** calculate the T test
	@f[
	  \frac{\mu - \mu_2}{\sqrt{pv (1 / N) + (1 / N_2)}}
	@f]
	where @f$\mu@f$ and @f$\mu_2@f$ is the mean and @f$ N@f$ and
	@f$ N_2@f$ is the sizes of this and the other dataset @a
	data2, and @a pv is the pooled variance.  The T test checks if
	two samples come from the same source. 
	@return the T statistic */
    return_type t_test(const dataset<@type@ >& data2);
    /** calculate the T test
	@f[
	  \frac{\mu - \mu_2}{\sqrt{pv (1 / N) + (1 / N_2)}}
	@f]
	where @f$\mu@f$ and @f$\mu_2@f$ is the mean and @f$ N@f$ and
	@f$ N_2@f$ is the sizes of this and the other dataset @a
	data2, and @a pv is the pooled variance.  The T test checks if
	two samples come from the same source. 
	@return the T statistic */
    return_type t_test(const container_type& data2);

    /** This member function returns the maximum value in dataset.
	The maximum value is defined as the value of the element @f$ 
	x_i@f$ which satisfies @f$ x_i >= x_j \forall j@f$. 
	@return the maximum element. */
    data_type max() const;
    /** This member function returns the minimum value in dataset.
	The minimum value is defined as the value of the element @f$ 
	x_i@f$ which satisfies @f$ x_i <= x_j \forall j@f$. 
	@return the minimum element. */
    data_type min() const;
    /** This member function returns a pair of numbers , where the
	first is the minimum of the dataset, and the second is the
	maximum of the dataset. 
	@return pair of minimum and maximum element */
    std::pair<data_type,data_type> minmax() const;
    
    /** This member function returns index of the maximum value in
	dataset. The maximum value is defined as the value of the
	element @f$ x_i@f$ which satisfies @f$ x_i >= x_j \forall
	j@f$.  
	@return the maximum element. */
    size_t max_index() const;
    /** This member function returns the index of the minimum value in
	dataset. The minimum value is defined as the value of the
	element @f$  x_i@f$ which satisfies @f$ x_i <= x_j \forall
	j@f$.  
	@return the minimum element. */
    size_t min_index() const;
    /** This member function returns a pair of index numbers, where
	the first is the minimum of the dataset, and the second is the
	maximum of the dataset.  
	@return pair of index to minimum and maximum element */
    std::pair<size_t,size_t> minmax_index() const;

    /** This function returns the median value of the dataset. 
	When the dataset has an odd number of elements the median is
	the value of element @f$ (n-1)/2@f$.  When the dataset has an
	even number of elements the median is the mean of the two
	nearest middle values, elements @f$ (n-1)/2@f$ and @f$ n/2@f$.
	Since the algorithm for computing the median involves
	interpolation this function always returns a floating-point
	number, even for integer data types. 
	@return the median */
    return_type median() const;

    /** This function returns a quantile value of the dataset.  The 
	quantile is determined by the @a f, a fraction between 0 and
	1.  For  example, to compute the value of the 75th percentile
	@a f should have the value 0.75.

	The quantile is found by interpolation, using the formula
	@f[
          quantile = (1 - \delta) x_i + \delta x_{i+1}
	@f]
	where @f$ i@f$ is @c floor((n-1)f) and @f$ \delta@f$ is @f$(n-1)f
	- i@f$. 

	Thus the minimum value of the array is given by @a f equal to
	zero, the maximum value is given by @a f equal to one and the
	median value is given by @a f equal to 0.5.  Since the
	algorithm for computing quantiles involves interpolation this
	function always returns a floating-point number, even for
	integer data types. 
	@return the @a f-th quantile */
    return_type quantile(const return_type& f) const;

    /** Sort the data set.  Note, that iterators are invalidated. */
    void sort();
    
  protected:
    container_type _data;
  };
  
  //__________________________________________________________________
  inline 
  dataset<@type@ >::dataset(const container_type& d) 
    : _data(d)
  {}
  
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::mean() const
  {
    return gsl_stats@low@_mean(&(_data[0]), 1, _data.size());
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::variance() const
  {
    return gsl_stats@low@_variance(&(_data[0]), 1, _data.size());
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::variance(const return_type& mean, bool apriori) const
  {
    if (apriori) 
      return gsl_stats@low@_variance_with_fixed_mean(&(_data[0]), 1, 
						     _data.size(), mean);
    return gsl_stats@low@_variance_m(&(_data[0]), 1, _data.size(), mean);
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::standard_deviation() const
  {
    return gsl_stats@low@_sd(&(_data[0]), 1, _data.size());
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::standard_deviation(const return_type& mean, 
					  bool apriori) const
  {
    if (apriori) 
      return gsl_stats@low@_sd_with_fixed_mean(&(_data[0]), 1, 
					       _data.size(), mean);
    return gsl_stats@low@_sd_m(&(_data[0]), 1, _data.size(), mean);
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::absolute_deviation() const
  {
    return gsl_stats@low@_absdev(&(_data[0]), 1, _data.size());
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::absolute_deviation(const return_type& mean) const
  {
    return gsl_stats@low@_absdev_m(&(_data[0]), 1, _data.size(), mean);
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::skew() const
  {
    return gsl_stats@low@_skew(&(_data[0]), 1, _data.size());
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::skew(const return_type& mean, 
			    const return_type& sd) const
  {
    return gsl_stats@low@_skew_m_sd(&(_data[0]), 1, _data.size(), mean, sd);
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::kurtosis() const
  {
    return gsl_stats@low@_kurtosis(&(_data[0]), 1, _data.size());
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::kurtosis(const return_type& mean, 
			    const return_type& sd) const
  {
    return gsl_stats@low@_kurtosis_m_sd(&(_data[0]), 1, 
					_data.size(), mean, sd);
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::auto_correlation() const
  {
    return gsl_stats@low@_lag1_autocorrelation(&(_data[0]), 1, _data.size());
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::auto_correlation(const return_type& mean) const
  {
    return gsl_stats@low@_lag1_autocorrelation_m(&(_data[0]), 1, 
						 _data.size(), mean);
  }
  
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::covariance(const container_type& data2) 
  {
    return gsl_stats@low@_covariance(&(_data[0]), 1, &(data2[0]), 1, 
				     _data.size());
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::covariance(const dataset<@type@ >& data2) 
  {
    return gsl_stats@low@_covariance(&(_data[0]), 1, &(data2._data[0]), 1, 
				     _data.size());
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::covariance(const container_type& data2, 
			       const return_type& mean, 
			       const return_type& mean2) 
  {
    return gsl_stats@low@_covariance_m(&(_data[0]), 1, &(data2[0]), 1, 
				       _data.size(), mean, mean2);
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::covariance(const dataset<@type@ >& data2, 
				  const return_type& mean, 
				  const return_type& mean2) 
  {
    return gsl_stats@low@_covariance_m(&(_data[0]), 1, &(data2._data[0]), 1, 
				       _data.size(), mean, mean2);
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::pooled_variance(const container_type& data2) 
  {
    return gsl_stats@low@_pvariance(&(_data[0]), 1, _data.size(), 
				    &(data2[0]), 1, data2.size());
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::pooled_variance(const dataset<@type@ >& data2) 
  {
    return gsl_stats@low@_pvariance(&(_data[0]), 1, _data.size(),
				    &(data2._data[0]), 1, data2.size());
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::t_test(const container_type& data2) 
  {
    return gsl_stats@low@_ttest(&(_data[0]), 1, _data.size(), 
				&(data2[0]), 1, data2.size());
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::t_test(const dataset<@type@ >& data2) 
  {
    return gsl_stats@low@_ttest(&(_data[0]), 1, _data.size(),
				&(data2._data[0]), 1, data2.size());
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::data_type 
  dataset<@type@ >::max() const 
  {
    return gsl_stats@low@_max(&(_data[0]), 1,_data.size());
  }
  //__________________________________________________________________
  inline 
  dataset<@type@ >::data_type 
  dataset<@type@ >::min() const 
  {
    return gsl_stats@low@_min(&(_data[0]), 1,_data.size());
  }
  //__________________________________________________________________
  inline 
  std::pair<dataset<@type@ >::data_type ,dataset<@type@ >::data_type>
  dataset<@type@ >::minmax() const 
  {
    std::pair<data_type,data_type> ret;
    gsl_stats@low@_minmax(&ret.first, &ret.second, 
			  &(_data[0]), 1,_data.size());
    return ret;
  }
  //__________________________________________________________________
  inline 
  size_t
  dataset<@type@ >::max_index() const 
  {
    return gsl_stats@low@_max_index(&(_data[0]), 1,_data.size());
  }
  //__________________________________________________________________
  inline 
  size_t
  dataset<@type@ >::min_index() const 
  {
    return gsl_stats@low@_min_index(&(_data[0]), 1,_data.size());
  }
  //__________________________________________________________________
  inline 
  std::pair<size_t,size_t>
  dataset<@type@ >::minmax_index() const 
  {
    std::pair<size_t,size_t> ret;
    gsl_stats@low@_minmax_index(&ret.first, &ret.second, 
				&(_data[0]), 1,_data.size());
    return ret;
  }
  
  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::median() const 
  {
    container_type tmp(_data);
    std::sort(tmp.begin(), tmp.end());
    return gsl_stats@low@_median_from_sorted_data(&(tmp[0]), 1,tmp.size());
  }

  //__________________________________________________________________
  inline 
  dataset<@type@ >::return_type 
  dataset<@type@ >::quantile(const return_type& f) const 
  {
    container_type tmp(_data);
    std::sort(tmp.begin(), tmp.end());
    return gsl_stats@low@_quantile_from_sorted_data(&(tmp[0]), 1,
						      tmp.size(), f);
  }

  //__________________________________________________________________
  inline 
  void
  dataset<@type@ >::sort() 
  {
    std::sort(_data.begin(), _data.end());
  }
    
}

#endif
//____________________________________________________________________
//
// EOF
//
