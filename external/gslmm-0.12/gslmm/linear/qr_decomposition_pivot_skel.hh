//
// $Id: qr_decomposition_pivot_skel.hh,v 1.4 2007-04-21 09:03:12 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::linear@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_linear_qr_decomposition_pivot@name@
#define GSLMM_linear_qr_decomposition_pivot@name@
#line 29 "qr_decomposition_pivot_skel.hh"
#ifndef __GSL_LINALG_H__
# include <gsl/gsl_linalg.h>
#endif
#ifndef GSLMM_permutation_permutation
# include <gslmm/permutation/permutation.hh>
#endif
#ifndef GSLMM_blas_blas@name@
# include <gslmm/blas/blas@name@.hh>
#endif
#ifndef GSLMM_linear_qr_decomposition@name@
# include <gslmm/linear/qr_decomposition@name@.hh>
#endif

/** @file   linear/qr_decomposition_pivot@name@.hh
    @author Christian Holm
    @date   Mon Mar 10 14:50:12 2003
    @brief  Base template for Linear Algebra classes */

namespace gslmm
{
  /** @brief class template specialisation for QR
      decompositions with column pivoting of matricies of type @type@.  
      @ingroup qr_decomposition_group

      The QR decomposition can be extended to the rank deficient case
      by introducing a column permutation @f$ P@f$,
      @f[
        A P = Q R
      @f]
      The first @f$ r@f$ columns of @f$ Q@f$ form an orthonormal basis
      for the range of @f$ A@f$ for a matrix with column rank @f$
      r@f$.  This decomposition can also be used to convert the linear
      system @f$ A x = b@f$ into the triangular system @f$ R y = Q^T
      b@f$, @f$ x = P y@f$, which can be solved by back-substitution
      and permutation.  We denote the QR decomposition with column
      pivoting by @f$ QRP^T@f$ since @f$ A = Q R P^T@f$.

      @todo implement gsl_linalg_QR_update
   */
  template <>
  struct qr_decomposition_pivot<@type@> : public qr_decomposition<@type@>
  {
    /** The vector type */
    typedef vector<@type@> vector_type;
    /** The matrix type */
    typedef matrix<@type@> matrix_type;
    /** The element type */
    typedef matrix_type::value_type value_type;
    /** The element type */
    typedef matrix_type::element_type element_type;
  private:
    /** The low level matrix type */
    typedef matrix_type::data_type data_type;
    /** The @f$ N@f$ of the QR decomposition */
    vector_type _n;
    /** The permutation @f$ P@f$ */
    permutation _p;
    /** Sign of permutation */
    int _sign;
    /** Hide base classes' member function */
    bool solve(const vector_type&, vector_type&, vector_type&) const
    {
      return false;
    }
    /** Hide base classes' member function */
    bool qt_multiply(vector_type&)  { return false; }
    /** Hide base classes' member function */
    bool q_multiply(vector_type&)  { return false; }
  public:
    /** Create an QR decomposition of the input matrix @a m. 
	Factorise a general @f$ M \times N@f$ matrix @f$ A@f$ into
	@f[
	   A P = Q R
	@f]
	where @f$ Q@f$ is orthogonal (@f$ M \times M@f$) and @f$ R@f$ is
	upper triangular (@f$ M \times N@f$).  When @f$ A@f$ is rank
	deficient, @f$ r = rank(A) < n@f$, then the permutation is 
	used to ensure that the lower @f$ n - r@f$ rows of @f$ R@f$
	are zero and the first @f$ r@f$ columns of @f$ Q@f$  form an
	orthonormal basis for @f$ A@f$. 
	
	@f$ Q@f$ is stored as a packed set of Householder
	transformations in the strict lower triangular part of the
	input matrix. 
	
	@f$ R@f$ is stored in the diagonal and upper triangle of the
	input matrix. 
	
	Column @f$ j@f$ of @f$ P@f$ is column @f$ k@f$ of the identity
	matrix, where @f$ k = P_j@f$.  The sign of the permutation is 
	@f$ (-1)^n@f$ where @f$ n@f$ is the number of interchanges in
	@f$ P@f$. 
	
	The full matrix for @f$ Q@f$ can be obtained as the product
	@f[ 
          Q = Q_k .. Q_2 Q_1
	@f]
	where @f$ k = \min(M,N)@f$ and 
	@f[
          Q_i = (I - \tau_i v_i v_i')
	@f]
	and where @f$ v_i@f$ is a Householder vector
	@f[
	  v_i = \left[1, m_{i+1,i}, m_{i+2,i}, ... , m_{M,i}\right]
	@f]
	This storage scheme is the same as in LAPACK. 
	@param m Matrix to decompose. 
	@param unpack If true, then separate values of @f$ Q@f$ and @f$
	R@f$ are stored. */
    qr_decomposition_pivot(const matrix_type& m, bool unpack=false);
    /** This member function solve the system @f$ A x = b@f$ using
	the @f$ QRP^T@f$ decomposition of @f$ A@f$.   This member
	function can be used regardless of whether the decompososition
	is stored in packed (@f$ QR, P, \tau@f$) or unpacked (@f$ Q,
	R@f$) form. 
	@param b The vector @f$ b@f$
	@param x The vector @f$ x@f$
	@return true on success  */
    virtual bool solve(const vector_type& b, vector_type& x) const;
    /** This member function solve the system @f$ A x = b@f$ using
	the QR decomposition of @f$ A@f$.  This member function
	can be used only if the decompososition is stored in packed
	(@f$ QR, P, \tau@f$).  
	@param x On input, the vector @f$ b@f$, and on output the
	vector @f$ x@f$  */
    virtual bool solve(vector_type& x) const;
    /** This function solves the triangular system @f$ R x = b@f$ for
	@f$ x@f$. This member function can be used only if the
	decompososition is stored in packed (@f$ QR, P, \tau@f$).  
	@param b The vector @f$ b@f$
	@param x On return, the vector @f$ x@f$ that solves @f$ R x =
	b@f$ 
	@return @c true on success.  */
    virtual bool r_solve(const vector_type& b, vector_type& x) const;
    /** This function solves the triangular system @f$ R x = b@f$ for
	@f$ x@f$ in-place. On input @f$ x@f$ should contain the
	right-hand side @f$ b@f$ and is replaced by the solution on
	output.  This member function can be used only if the
	decompososition is stored in packed (@f$ QR, P, \tau@f$).  
	@param x On input, the vector @f$ b@f$ On return, the vector
	@f$ x@f$ that solves @f$ R x = b@f$ 
	@return @c true on success. */
    virtual bool r_solve(vector_type& x) const;
    /** This function solves the system @f$ R x = Q^T b@f$ for @f$
	x@f$. It can be used when the QR decomposition of a matrix is
	wanted in unpacked form as @f$(Q, R)@f$
	@param b The vector @f$ b@f$ 
	@param x The vector @f$ x@f$, the solution to @f$ R x = Q^T
	b@f$. 
	@return  @c true on success. */
    virtual bool qr_solve(const vector_type& b, vector_type& x) const;
    /** This function performs a rank-1 update @f$ w v^T@f$ of the 
	@f$ QR@f$ decomposition (@f$ Q, R@f$). The update is given by
	@f[
	Q'R' = Q R + w v^T
	@f]
	where the output matrices @f$ Q'@f$ and @f$ R'@f$ are also
	orthogonal and right triangular.
	Update a @f$ Q R P^T@f$ factorisation for @f$ A P = Q R@f$,  
	@f$ A' = A + u v^T@f$,
	@f{eqnarray*}
	Q' R' P^-1 = QR P^-1 + u v^T
                   = Q (R + Q^T u v^T P ) P^-1
		   = Q (R + w v^T P) P^-1
        @f}
	where @f$ w = Q^T u.@f$  Algorithm from Golub and Van Loan,
	"Matrix Computations", Section 12.5 (Updating Matrix
	Factorizations, Rank-One Changes)  
    */
    virtual bool update(const vector_type& w, const vector_type& v);
    /** @return Sign of the permutation matrix @f$ P@f$ */
    virtual int sign() const { return _sign; }
    /** @return The permutation @f$ P@f$ of the QR decomposition */
    virtual const permutation& p() const { return _p; }
  };
  //__________________________________________________________________
  inline 
  qr_decomposition_pivot<@type@>::qr_decomposition_pivot(const matrix_type& m, 
							 bool unpack) 
    : qr_decomposition<@type@>(m, true),
      _n(m.column_size()),
      _p(m.column_size()), 
      _sign(0)
  {
    int ret = 0;
    if (!unpack) 
      ret= gsl_linalg@low@_QRPT_decomp(_matrix, _tau._vector, 
				       _p._permutation, &_sign, 
				       _n._vector);
    else {
      _r = new matrix_type(column_size(), column_size());
      _q = new matrix_type(row_size(),    column_size());
      ret = gsl_linalg@low@_QRPT_decomp2(m._matrix, _q->_matrix, 
					 _r->_matrix, _tau._vector, 
					 _p._permutation, 
					 &_sign, _n._vector);
      matrix_matrix_product(1., *_q, *_r, 0., *this);
    }
    (void)ret;
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition_pivot<@type@>::solve(const vector_type& b, 
					vector_type& x) const
  {
    int ret = 0;
    if (_r) 
      ret = gsl_linalg@low@_QRPT_QRsolve(_q->_matrix, _r->_matrix, 
					 _p._permutation, b._vector, 
					 x._vector);
    else 
      ret = gsl_linalg@low@_QRPT_solve(_matrix, _tau._vector, 
				       _p._permutation, b._vector, 
				       x._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition_pivot<@type@>::solve(vector_type& x) const
  {
    if (_r) return 1;
    int ret = gsl_linalg@low@_QRPT_svx(_matrix, _tau._vector, 
				       _p._permutation, x._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition_pivot<@type@>::r_solve(const vector_type& b, 
					  vector_type& x) const
  {
    int ret = gsl_linalg@low@_QRPT_Rsolve(_matrix, _p._permutation,
					  b._vector, x._vector);
    return ret == 0;
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition_pivot<@type@>::r_solve(vector_type& x) const
  {
    int ret = gsl_linalg@low@_QRPT_Rsvx(_matrix, _p._permutation, 
					x._vector);
    return ret == 0;
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition_pivot<@type@>::qr_solve(const vector_type& b, 
					   vector_type& x) const
  {
    unpack();
    int ret = gsl_linalg@low@_QRPT_QRsolve(_q->_matrix, _r->_matrix, 
					   _p._permutation, 
					   b._vector, x._vector);
    return ret == 0;
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition_pivot<@type@>::update(const vector_type& w, 
					 const vector_type& v)
  {
    vector_type tmp(w);
    int ret = gsl_linalg@low@_QRPT_update(_q->_matrix, _r->_matrix,
					  _p._permutation, 
					  tmp._vector, v._vector);
    return ret == GSL_SUCCESS;
  }

}

#endif
//____________________________________________________________________
//
// EOF
//
  
