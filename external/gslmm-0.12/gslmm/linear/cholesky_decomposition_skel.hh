//
// $Id: cholesky_decomposition_skel.hh,v 1.3 2007-04-21 09:03:12 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::linear@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_cholesky_decomposition@name@
#define GSLMM_cholesky_decomposition@name@
#line 29 "cholesky_decomposition_skel.hh"
#ifndef __GSL_LINALG_H__
# include <gsl/gsl_linalg.h>
#endif
#ifndef GSLMM_linear_linear_base
# include <gslmm/linear/linear_base.hh>
#endif
#ifndef GSLMM_matrix@name@
# include <gslmm/vectormatrix/matrix@name@.hh>
#endif
#ifndef GSLMM_vector@name@
# include <gslmm/vectormatrix/vector@name@.hh>
#endif
#if @complex@
# ifndef GSLMM@name@
#  include <gslmm/compleks/@cname@.hh>
# endif
#endif

/** @file   linear/cholesky_decomposition@name@.hh
    @author Christian Holm
    @date   Mon Mar 10 14:50:12 2003
    @brief  Base template for Linear Algebra classes */

namespace gslmm
{
  /** @brief class template specialisation for Cholesky
      decompositions of matricies of type @type@.  
      @ingroup cholesky_decomposition_group

      A symmetric, positive definite square matrix A has a Cholesky 
      decomposition into a product of a lower triangular matrix @f$
      L@f$ and its transpose @f$ L^T@f$,
      @f[
      A = L L^T
      @f]

      This is sometimes referred to as taking the square-root of a
      matrix. The Cholesky decomposition can only be carried out when
      all the eigenvalues of the matrix are positive.  This
      decomposition can be used to convert the linear system @f$ A x =
      b@f$ into a pair of triangular systems (@f$ L y = b@f$, @f$ L^T
      x = y@f$), which can be solved by forward and
      back-substitution. 

      @todo Implement gsl_linalg_cholesky_decomp_unit
   */
  template <>
  struct cholesky_decomposition<@type@> : public matrix<@type@>
  {
    /** The vector type */
    typedef vector<@type@> vector_type;
    /** The matrix type */
    typedef matrix<@type@> matrix_type;
    /** The element type */
    typedef matrix_type::value_type value_type;
    /** The element type */
    typedef matrix_type::element_type element_type;
  private:
    /** The low level matrix type */
    typedef matrix_type::data_type data_type;
    /** The Q of the QR decomposition of the input matrix */
    mutable matrix_type*  _l;
    /** The R of the QR decomposition of the input matrix */
    mutable matrix_type*  _lt;
    /** Diagonal */
    vector_type _d;
  protected:
    /** Unpack @f$ LL^T@f$ into @f$ L@f$ and @f$ L^T@f$. */
    void unpack() const
    {
      if (_l) return;
      _l  = new matrix_type(row_size(), column_size());
      _lt = new matrix_type(row_size(), column_size());
      for (size_t row = 0; row < row_size(); row++) 
	for (size_t col = 0; col <= row; col++) 
	  (*_l)(row, col) = gsl_matrix@low@_get(_matrix, row, col);      
      for (size_t row = 0; row < row_size(); row++) 
	for (size_t col = row; col < column_size(); col++) 
	  (*_lt)(row, col) = gsl_matrix@low@_get(_matrix, row, col);
    }
  public:
    /** Create an Cholesky decomposition of the input matrix @a m. */
    cholesky_decomposition(const matrix_type& m, bool unit=false) 
      : matrix_type(m), 
	_l(0), 
	_lt(0),
	_d(m.row_size())
    {
      int ret;
      if (unit) 
	ret = gsl_linalg@low@_cholesky_decomp_unit(_matrix, _d._vector);
      else {
	ret = gsl_linalg@low@_cholesky_decomp(_matrix);
	for (size_t i = 0; i < row_size(); i++) _d[i] = 1;
      }
      (void)ret;
    }
    /** Destructor  */
    virtual ~cholesky_decomposition() 
    {
      if (_l)  delete _l;
      if (_lt) delete _lt;
    }
    /** This member function solve the system @f$ A x = b@f$ using
	the Cholesky decomposition of @f$ A@f$. 
	@param b The vector @f$ b@f$
	@param x The vector @f$ x@f$
	@return true on success  */
    bool solve(const vector_type& b, vector_type& x) const
    {
      int ret = gsl_linalg@low@_cholesky_solve(_matrix, b._vector, x._vector);
      return (ret == 0);
    }
    /** This member function solve the system @f$ A x = b@f$ using
	the Cholesky decomposition of @f$ A@f$. 
	@param x On input, the vector @f$ b@f$, and on output the
	vector @f$ x@f$  */
    bool solve(vector_type& x) const
    {
      int ret = gsl_linalg@low@_cholesky_svx(_matrix, x._vector);
      return (ret == 0);
    }
    /** @return The scale diagonal of the decomposition */
    const vector_type& d() const 
    {
      return _d;
    }
    /** @return The matrix @f$ L@f$ of the @f$ LL^T@f$ decomposition
	of @f$ A@f$ */ 
    const matrix_type& l() const 
    {
      unpack();
      return *_l;
    }
    /** @return The matrix @f$ L^T@f$ of the @f$ LL^T@f$ decomposition
	of @f$ A@f$ */ 
    const matrix_type& lt() const 
    {
      unpack();
      return *_lt;
    }
    /** @return The matrix @f$ LL^T@f$ of the Cholesky decomposition
	of @f$ A@f$ */  
    const matrix_type& llt() const 
    {
      return *this;
    }
  };
}

#endif
//____________________________________________________________________
//
// EOF
//
  
