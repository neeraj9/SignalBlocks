//
// $Id: sv_decomposition_skel.hh,v 1.6 2007-04-21 09:03:12 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::linear@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_sv_decomposition@name@
#define GSLMM_sv_decomposition@name@
#line 29 "sv_decomposition_skel.hh"
#ifndef __GSL_LINALG_H__
# include <gsl/gsl_linalg.h>
#endif
#ifndef GSLMM_linear_linear_base
# include <gslmm/linear/linear_base.hh>
#endif
#ifndef GSLMM_matrix@name@
# include <gslmm/vectormatrix/matrix@name@.hh>
#endif
#ifndef GSLMM_vector@name@
# include <gslmm/vectormatrix/vector@name@.hh>
#endif
#if @complex@
# ifndef GSLMM@name@
#  include <gslmm/compleks/@cname@.hh>
# endif
#endif

/** @file   linear/sv_decomposition@name@.hh
    @author Christian Holm
    @date   Mon Mar 10 14:50:12 2003
    @brief  Base template for Linear Algebra classes */

namespace gslmm
{
  /** @brief class template specialisation for Singular Value
      decompositions of matricies of type @type@.  
      @ingroup sv_decomposition_group

      A general rectangular @f$ M\times N@f$ matrix @f$ A@f$ has a
      singular value decomposition (SVD) into the product of an 
      @f$ M\times N@f$ orthogonal matrix @f$ U@f$, an @f$ N\times N@f$
      diagonal matrix of singular values @f$ S@f$ and the transpose of
      an @f$ N\times @f$ orthogonal square matrix @f$ V@f$, 
      @f[
        A = U S V^T
      @f]

      The singular values @f$ \sigma_i = S_{ii}@f$ are all
      non-negative and are generally chosen to form a non-increasing
      sequence @f$ \sigma_1\ge\sigma_2\ge\ldots\ge\sigma_N\ge0@f$.

      The singular value decomposition of a matrix has many practical
      uses.  The condition number of the matrix is given by the ratio
      of the largest singular value to the smallest singular
      value.  The presence of a zero singular value indicates that the
      matrix is singular. The number of non-zero singular values
      indicates the rank of the matrix.  In practice singular value
      decomposition of a rank-deficient matrix will not produce exact
      zeroes for singular values, due to finite numerical
      precision. Small singular values should be edited by choosing a
      suitable tolerance. 
  */
  template <>
  struct sv_decomposition<@type@> : public matrix<@type@>
  {
    enum algorithm_t {
      normal, 
      modified, 
      jacobi
    };
    /** The vector type */
    typedef vector<@type@> vector_type;
    /** The matrix type */
    typedef matrix<@type@> matrix_type;
    /** The element type */
    typedef matrix_type::value_type value_type;
    /** The element type */
    typedef matrix_type::element_type element_type;
  private:
    /** The low level matrix type */
    typedef matrix_type::data_type data_type;
    /** The singular values of the SV decomposition */
    vector_type _s;
    /** The work-space of the SV decomposition */
    vector_type _w;
    /** The Q of the SV decomposition of the input matrix */
    matrix_type _v;
  public:
    /** Create an SV decomposition of the input matrix @a m. 
	@param m    Matrix to make SV decomposition of
	@param algo Algorithm to use */
    sv_decomposition(const matrix_type& m, algorithm_t algo) 
      : matrix_type(m), 
	_s(m.column_size()), 
	_w(m.column_size()),
	_v(m.column_size(), m.column_size())
    {
      int ret = 0;
      switch (algo) {
      case modified: 
	{
	  matrix_type x(m.column_size(), m.column_size());
	  ret = gsl_linalg@low@_SV_decomp_mod(_matrix, x._matrix, _v._matrix, 
					      _s._vector, _w._vector);
	}
	break;
      case jacobi:
	ret = gsl_linalg@low@_SV_decomp_jacobi(_matrix,_v._matrix, 
					       _s._vector);
	break;
      case normal:
	gsl_linalg@low@_SV_decomp(_matrix, _v._matrix, 
				  _s._vector, _w._vector);
      }
      (void)ret;
    }
    /** Destructor  */
    virtual ~sv_decomposition() 
    {}
    /** This member function solve the system @f$ A x = b@f$ using
	the SV decomposition of @f$ A@f$. 

	Only non-zero singular values are used in computing the
	solution.  The parts of the solution corresponding to singular
	values of zero are ignored.  Other singular values can be
	edited out by setting them to zero before calling this
	function.

	In the over-determined case where A has more rows than columns
	the system is solved in the least squares sense, returning the
	solution @f$ x@f$ which minimizes @f$\|A x - b\|_2@f$.

	@param b The vector @f$ b@f$
	@param x The vector @f$ x@f$
	@return true on success  */
    bool solve(const vector_type& b, vector_type& x) const
    {
      int ret = gsl_linalg@low@_SV_solve(_matrix, _v._matrix, _s._vector,
					 b._vector, x._vector);
      return (ret == 0);
    }
    /** This member function solve the system @f$ A x = b@f$ using
	the SV decomposition of @f$ A@f$. 
	@param x On input, the vector @f$ b@f$, and on output the
	vector @f$ x@f$  */
    bool solve(vector_type& x) const
    {
      const vector_type b(x);
      return solve(b, x);
    }
    /** @return The matrix @f$ V@f$ of the SV decomposition of @f$
	A@f$ */ 
    const matrix_type& v() const 
    {
      return _v;
    }
    /** @return The diagonal of @f$ S@f$ of the SV decomposition of @f$
	A@f$ as a vector.   */ 
    const vector_type& s() const 
    {
      return _s;
    }
    /** @return The diagonal of @f$ S@f$ of the SV decomposition of @f$
	A@f$ as a vector.  This can be used to reject too low singular
	values before using the solve member function.   For example 
	@code 
	gslmm::sv_decomposition<double> sv(a);
	gslmm::vector<double>&          s = sv.s();
	for (size_t i = 0;i < s.size(); i++) if (s[i] < tolerance) s[i] = 0;
        sv.solve(b, x);
	@endcode 
    */ 
    vector_type& s() 
    {
      return _s;
    }
    /** @return The matrix @f$ U@f$ of the SV decomposition of @f$
	A@f$ */  
    const matrix_type& u() const 
    {
      return *this;
    }
  };
}

#endif
//____________________________________________________________________
//
// EOF
//
  
