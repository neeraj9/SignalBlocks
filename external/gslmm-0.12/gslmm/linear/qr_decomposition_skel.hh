//
// $Id: qr_decomposition_skel.hh,v 1.6 2006-05-09 07:40:34 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::linear@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_qr_decomposition@name@
#define GSLMM_qr_decomposition@name@
#line 29 "qr_decomposition_skel.hh"
#ifndef __GSL_LINALG_H__
# include <gsl/gsl_linalg.h>
#endif
#ifndef GSLMM_linear_linear_base
# include <gslmm/linear/linear_base.hh>
#endif
#ifndef GSLMM_vectormatrix_matrix@name@
# include <gslmm/vectormatrix/matrix@name@.hh>
#endif
#ifndef GSLMM_vectormatrix_vector@name@
# include <gslmm/vectormatrix/vector@name@.hh>
#endif
#if @complex@
# ifndef GSLMM_compleks@name@
#  include <gslmm/compleks/@cname@.hh>
# endif
#endif

/** @file   linear/qr_decomposition@name@.hh
    @author Christian Holm
    @date   Mon Mar 10 14:50:12 2003
    @brief  Base template for Linear Algebra classes */

namespace gslmm
{
  /** @brief class template specialisation for QR
      decompositions of matricies of type @type@.  
      @ingroup qr_decomposition_group

      This functions factorize the square matrix @f$ M\times N@f$
      matrix @f$ A@f$ into the QR decomposition into the product of an
      orthogonal @f$ M\times M@f$ square matrix @f$ Q@f$ (where @f$
      Q^T Q = I@f$) and an @f$ M\times N@f$ right-triangular matrix
      @f$ R@f$,
      @f[
        A = Q R
      @f]

      This decomposition can be used to convert the linear system 
      @f$ A x = b@f$ into the triangular system @f$ R x = Q^T b@f$,
      which can be solved by back-substitution. Another use of the QR
      decomposition is to compute an orthonormal basis for a set of
      vectors. The first @f$ N@f$  columns of @f$ Q@f$ form an
      orthonormal basis for the range of @f$ A@f$, @f$ ran(A)@f$, when
      @f$ A@f$ has full column rank.
   */
  template <>
  struct qr_decomposition<@type@> : public matrix<@type@>
  {
  public:
    /** The vector type */
    typedef vector<@type@> vector_type;
    /** The matrix type */
    typedef matrix<@type@> matrix_type;
    /** The element type */
    typedef matrix_type::value_type value_type;
    /** The element type */
    typedef matrix_type::element_type element_type;

    /** Create an QR decomposition of the input matrix @a m. 
	A reference to the input matrix is stored for later use. */
    qr_decomposition(const matrix_type& m);
    /** Destructor  */
    virtual ~qr_decomposition();
    /** This member function solve the system @f$ A x = b@f$ using
	the QR decomposition of @f$ A@f$.   The input matrix @f$ A@f$
	must be square. This can be used to find the inverse of matrix
	@f$ A@f$ by doing a back-subsitution of the identity matrix. 
	@code 
	gslmm::qr_decomposition<T> QR(A);
	gslmm::matrix<T> Ainv(A.row_size(), B.column_size());
	for (size_t i = 0; i < A.row_size(); i++) {
	  gslmm::vector<T> v(A.row_size());
	  gslmm::vector<T> x(A.row_size());
	  v.basis(i);
          QR.solve(v, x);
	  for (size_t j = 0; j < A.column_size(); j++) Ainv(i,j) = x[j];
	}
	@endcode
	@param b The vector @f$ b@f$
	@param x The vector @f$ x@f$
	@return true on success  */
    virtual bool solve(const vector_type& b, vector_type& x) const;
    /** This member function solve the system @f$ A x = b@f$ using
	the QR decomposition of @f$ A@f$. The input matrix @f$ A@f$
	must be square. This can be used to find the inverse of matrix
	@f$ A@f$ by doing a back-subsitution of the identity matrix. 
	@code 
	gslmm::qr_decomposition<T> QR(A);
	gslmm::matrix<T> Ainv(A.row_size(), B.column_size());
	for (size_t i = 0; i < A.row_size(); i++) {
	  gslmm::vector<T> v(A.row_size());
	  v.basis(i);
          QR.solve(v);
	  for (size_t j = 0; j < A.column_size(); j++) Ainv(i,j) = x[j];
	}
	@endcode
	@param x On input, the vector @f$ b@f$, and on output the
	vector @f$ x@f$  */
    virtual bool solve(vector_type& x) const;
    /** This function finds the least squares solution to the
	overdetermined system @f$ A x = b@f$ where the matrix @f$ A@f$
	has more rows than columns.  The least squares solution
	minimizes the Euclidean norm of the residual, @f$ ||Ax -
	b||@f$.  The routine uses the QR decomposition of @f$ A@f$.
	The solution is returned in @f$ x@f$.  The residual is computed as a
	by-product and stored in @f$ r@f$.
	@param b The input vector @f$ b@f$.  Must have the same
	dimension as the number of rows in @f$ A@f$.
	@param x The output solution vector @f$ x@f$ Must have the same 
	dimension as the number of columns in @f$ A@f$. 
	@param r The initial residual vector @f$ r@f$.   Must have the same
	dimension as the number of rows in @f$ A@f$.
	@return True on success. */
    virtual bool solve(const vector_type& b, vector_type& x, 
		       vector_type& r) const;
    /** This function solves the triangular system @f$ R x = b@f$ for
	@f$ x@f$. It may be useful if the product @f$ b' = Q^T b@f$ has
	already been computed using qt_multiply
	@param b The vector @f$ b@f$
	@param x On return, the vector @f$ x@f$ that solves @f$ R x =
	b@f$ 
	@return @c true on success.  */
    virtual bool r_solve(const vector_type& b, vector_type& x) const;
    /** This function solves the triangular system @f$ R x = b@f$ for
	@f$ x@f$ in-place. On input @f$ x@f$ should contain the
	right-hand side @f$ b@f$ and is replaced by the solution on
	output. This function may be useful if the product @f$ b' =
	Q^T b@f$ has already been computed using qt_multiply 
	@param x On input, the vector @f$ b@f$ On return, the vector
	@f$ x@f$ that solves @f$ R x = b@f$ 
	@return @c true on success. */
    virtual bool r_solve(vector_type& x) const;
    /** This function solves the system @f$ R x = Q^T b@f$ for @f$
	x@f$. It can be used when the QR decomposition of a matrix is
	wanted in unpacked form as @f$(Q, R)@f$
	@param b The vector @f$ b@f$ 
	@param x The vector @f$ x@f$, the solution to @f$ R x = Q^T
	b@f$. 
	@return  @c true on success. */
    virtual bool qr_solve(const vector_type& b, vector_type& x) const;
    /** This function applies the matrix @f$ Q^T@f$ encoded in the 
	decomposition to the vector @f$ v@f$, storing the result @f$
	Q^T v@f$ in @f$ v@f$.  The matrix multiplication is carried out
	directly using the encoding of the Householder vectors without
	needing to form the full matrix @f$ Q^T@f$.
	@param v On input, the vector @f$ v@f$.  On output the product
	@f$ Q^T v@f$. 
	@return @c true on success. */
    virtual bool qt_multiply(vector_type& v) const;
    /** This function performs a rank-1 update @f$ w v^T@f$ of the 
	@f$ QR@f$ decomposition (@f$ Q, R@f$). The update is given by
	@f[
	Q'R' = Q R + w v^T
	@f]
	where the output matrices @f$ Q'@f$ and @f$ R'@f$ are also
	orthogonal and right triangular. Note that @f$ w@f$ is
	destroyed by the update. */
    virtual bool update(const vector_type& w, const vector_type& v);
    /** This function applies the matrix @f$ Q@f$ encoded in the 
	decomposition to the vector @f$ v@f$, storing the result @f$
	Q v@f$ in @f$ v@f$.  The matrix multiplication is carried out
	directly using the encoding of the Householder vectors without
	needing to form the full matrix @f$ Q@f$.
	@param v On input, the vector @f$ v@f$.  On output the product
	@f$ Q v@f$. 
	@return @c true on success. */
    virtual bool q_multiply(vector_type& v) const;
    /** @return The matrix @f$ R@f$ of the QR decomposition of @f$
	A@f$ */ 
    const matrix_type& r() const;
    /** @return The matrix @f$ Q@f$ of the QR decomposition of @f$
	A@f$ */ 
    const matrix_type& q() const;
    /** @return The matrix @f$ QR@f$ of the QR decomposition of @f$
	A@f$ */  
    const matrix_type& qr() const;
  protected:
    /** The low level matrix type */
    typedef matrix_type::data_type data_type;
    /** The @f$ tau@f$ of the QR decomposition */
    vector_type _tau;
    /** The Q of the QR decomposition of the input matrix */
    mutable matrix_type*  _q;
    /** The R of the QR decomposition of the input matrix */
    mutable matrix_type*  _r;
    /** Unpack QR into @f$ Q@f$ and @f$ R@f$. */
    void unpack() const;
    /** Create an QR decomposition of the input matrix @a m. 
	A reference to the input matrix is stored for later use. */
    qr_decomposition(const matrix_type& m, bool nodo);
  };
  //__________________________________________________________________
  inline
  qr_decomposition<@type@>::qr_decomposition(const matrix_type& m) 
    : matrix_type(m), 
      _tau(std::min(m.row_size(), m.column_size())), 
      _q(0), 
      _r(0)
  {
    int ret = gsl_linalg@low@_QR_decomp(_matrix, _tau._vector);
    (void)ret;
  }
  //__________________________________________________________________
  inline
  qr_decomposition<@type@>::qr_decomposition(const matrix_type& m, bool) 
    : matrix_type(m), 
      _tau(std::min(m.row_size(), m.column_size())), 
      _q(0), 
      _r(0)
  {}
  //__________________________________________________________________
  inline
  qr_decomposition<@type@>::~qr_decomposition() 
  {
    if (_q) delete _q;
    if (_r) delete _r;
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::solve(const vector_type& b, vector_type& x) const
  {
    int ret = gsl_linalg@low@_QR_solve(_matrix, _tau._vector, 
				       b._vector, x._vector);
    return (ret == 0);
  }  
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::solve(vector_type& x) const
  {
    int ret = gsl_linalg@low@_QR_svx(_matrix, _tau._vector, x._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::solve(const vector_type& b, vector_type& x, 
				  vector_type& r) const
  {
    int ret = gsl_linalg@low@_QR_lssolve(_matrix, _tau._vector, 
					 b._vector, x._vector, r._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::r_solve(const vector_type& b, 
				    vector_type& x) const
  {
    int ret = gsl_linalg@low@_QR_Rsolve(_matrix, b._vector, x._vector);
    return ret == 0;
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::r_solve(vector_type& x) const
  {
    int ret = gsl_linalg@low@_QR_Rsvx(_matrix, x._vector);
    return ret == 0;
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::qr_solve(const vector_type& b, 
				     vector_type& x) const
  {
    unpack();
    int ret = gsl_linalg@low@_QR_QRsolve(_q->_matrix, _r->_matrix, 
					 b._vector, x._vector);
    return ret == 0;
  }      
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::qt_multiply(vector_type& v) const
  {
    int ret = gsl_linalg@low@_QR_QTvec(_matrix, _tau._vector, v._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::update(const vector_type& w, const vector_type& v)
  {
    vector_type tmp(w);
    int ret = gsl_linalg@low@_QR_update (q()._matrix, r()._matrix,
					 tmp._vector, v._vector);
    return ret == GSL_SUCCESS;
  }
  //__________________________________________________________________
  inline bool
  qr_decomposition<@type@>::q_multiply(vector_type& v) const
  {
    int ret = gsl_linalg@low@_QR_Qvec(_matrix, _tau._vector, v._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline const qr_decomposition<@type@>::matrix_type&
  qr_decomposition<@type@>::r() const 
  {
    unpack();
    return *_r;
  }
  //__________________________________________________________________
  inline const qr_decomposition<@type@>::matrix_type&
  qr_decomposition<@type@>::q() const 
  {
    unpack();
    return *_q;
  }
  //__________________________________________________________________
  inline const qr_decomposition<@type@>::matrix_type&
  qr_decomposition<@type@>::qr() const
  {
    return *this;
  }
  //__________________________________________________________________
  inline void
  qr_decomposition<@type@>::unpack() const
  {
    if (_r) return;
    _q = new matrix_type(row_size(), row_size());
    _r = new matrix_type(row_size(), column_size());
    gsl_linalg@low@_QR_unpack(_matrix, _tau._vector, 
			      _q->_matrix, _r->_matrix);
  }
}

#endif
//____________________________________________________________________
//
// EOF
//
  
