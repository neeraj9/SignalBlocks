//
// $Id: lq_decomposition_skel.hh,v 1.3 2006-05-09 07:40:34 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::linear@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_linear_lq_decomposition@name@
#define GSLMM_linear_lq_decomposition@name@
#line 29 "lq_decomposition_skel.hh"
#ifndef __GSL_LINALG_H__
# include <gsl/gsl_linalg.h>
#endif
#ifndef GSLMM_linear_linear_base
# include <gslmm/linear/linear_base.hh>
#endif
#ifndef GSLMM_vectormatrix_matrix@name@
# include <gslmm/vectormatrix/matrix@name@.hh>
#endif
#ifndef GSLMM_vectormatrix_vector@name@
# include <gslmm/vectormatrix/vector@name@.hh>
#endif
#if @complex@
# ifndef GSLMM_compleks@name@
#  include <gslmm/compleks/@cname@.hh>
# endif
#endif

/** @file   linear/lq_decomposition@name@.hh
    @author Christian Holm
    @date   Mon Mar 10 14:50:12 2003
    @brief  Base template for Linear Algebra classes */

namespace gslmm
{
  /** @brief class template specialisation for LQ
      decompositions of matricies of type @type@.  
      @ingroup lq_decomposition_group

      Factorise a general @f$ N\times M@f$ matrix @f$ A@f$ into
      @f[
      A = L Q
      @f]
      where @f$ Q@f$ is orthogonal (@f$ M \times M@f$) and @f$ L@f$ is
      lower triangular (@f$ N \times M@f$). 
 
      @f$ Q@f$ is stored as a packed set of Householder
      transformations in the strict upper triangular part of the input
      matrix. 
 
      @f$ R@f$ is stored in the diagonal and lower triangle of the
      input matrix. 
 
      The full matrix for @f$ Q@f$ can be obtained as the product
      @f[
      Q = Q_k .. Q_2 Q_1
      @f]
      where @f$ k = min(M,N)@f$ and
      @f[
      Q_i = (I - \tau_i * v_i * v_i')
      @f]
      and where @f$ v_i@f$ is a Householder vector
      @f[
      v_i = \left[1, m_{i+1,i}, m_{i+2,i}, ... , m_{M,i}\right]
      @f]
      This storage scheme is the same as in LAPACK.  
      @todo gsl_linalg_L_solve_T
  */
  template <>
  struct lq_decomposition<@type@> : public matrix<@type@>
  {
  public:
    /** The vector type */
    typedef vector<@type@> vector_type;
    /** The matrix type */
    typedef matrix<@type@> matrix_type;
    /** The element type */
    typedef matrix_type::value_type value_type;
    /** The element type */
    typedef matrix_type::element_type element_type;

    /** Create an LQ decomposition of the input matrix @a m. 
	A reference to the input matrix is stored for later use. */
    lq_decomposition(const matrix_type& m);
    /** Destructor  */
    virtual ~lq_decomposition();
    /** This member function solve the system @f$ x^T A = b^T@f$ using
	the LQ decomposition of @f$ A@f$,
	@f[
	x^T L = b^T Q^T
	@f]
	The input matrix @f$ A@f$ must be square. This can be used to
	find the inverse of matrix @f$ A@f$ by doing a
	back-subsitution of the identity matrix.
	@code 
	gslmm::lq_decomposition<T> LQ(A);
	gslmm::matrix<T> Ainv(A.row_size(), B.column_size());
	for (size_t i = 0; i < A.row_size(); i++) {
	  gslmm::vector<T> v(A.row_size());
	  gslmm::vector<T> x(A.row_size());
	  v.basis(i);
          LQ.solve(v, x);
	  for (size_t j = 0; j < A.column_size(); j++) Ainv(i,j) = x[j];
	}
	@endcode
	@param b The vector @f$ b@f$
	@param x The vector @f$ x@f$
	@return true on success  */
    virtual bool solve(const vector_type& b, vector_type& x) const;
    /** This member function solve the system @f$ x^T A = b^T@f$ using
	the LQ decomposition of @f$ A@f$,
	@f[
	x^T L = b^T Q^T
	@f]
	The input matrix @f$ A@f$ must be square. This can be used to
	find the inverse of matrix @f$ A@f$ by doing a
	back-subsitution of the identity matrix.  
	@code 
	gslmm::lq_decomposition<T> LQ(A);
	gslmm::matrix<T> Ainv(A.row_size(), B.column_size());
	for (size_t i = 0; i < A.row_size(); i++) {
	  gslmm::vector<T> v(A.row_size());
	  v.basis(i);
          LQ.solve(v);
	  for (size_t j = 0; j < A.column_size(); j++) Ainv(i,j) = x[j];
	}
	@endcode
	@param x On input, the vector @f$ b@f$, and on output the
	vector @f$ x@f$  */
    virtual bool solve(vector_type& x) const;
    /** This function finds the least squares solution to the
	overdetermined system @f$ x^T A = b^T@f$ where the matrix @f$
	A@f$ has more rows than columns.  The least squares solution
	minimizes the Euclidean norm of the residual, @f$ ||Ax -
	b||@f$.  The routine uses the LQ decomposition of @f$ A@f$.
	The solution is returned in @f$ x@f$.  The residual is computed as a
	by-product and stored in @f$ r@f$.
	@param b The input vector @f$ b@f$.  Must have the same
	dimension as the number of rows in @f$ A@f$.
	@param x The output solution vector @f$ x@f$ Must have the same 
	dimension as the number of columns in @f$ A@f$. 
	@param r The initial residual vector @f$ r@f$.   Must have the same
	dimension as the number of rows in @f$ A@f$.
	@return True on success. */
    virtual bool solve(const vector_type& b, vector_type& x, 
		       vector_type& r) const;
    /** This function solves the triangular system @f$ x^T L = b^T@f$
	for @f$ x@f$. It may be useful if the product @f$ b' = Q^T
	b@f$ has already been computed using lq_multiply
	@param b The vector @f$ b@f$
	@param x On return, the vector @f$ x@f$ that solves @f$ L x =
	b@f$ 
	@return @c true on success.  */
    virtual bool l_solve(const vector_type& b, vector_type& x) const;
    /** This function solves the triangular system @f$ x^T L = b^T@f$
	for @f$ x@f$ in-place. On input @f$ x@f$ should contain the
	right-hand side @f$ b@f$ and is replaced by the solution on
	output. This function may be useful if the product @f$ b' =
	Q^T b@f$ has already been computed using qt_multiply 
	@param x On input, the vector @f$ b@f$ On return, the vector
	@f$ x@f$ that solves @f$ L x = b@f$ 
	@return @c true on success. */
    virtual bool l_solve(vector_type& x) const;
    /** This function solves the system @f$ R x = Q^T b@f$ for @f$
	x@f$. It can be used when the LQ decomposition of a matrix is
	wanted in unpacked form as @f$(Q, R)@f$
	@param b The vector @f$ b@f$ 
	@param x The vector @f$ x@f$, the solution to @f$ R x = Q^T
	b@f$. 
	@return  @c true on success. */
    virtual bool lq_solve(const vector_type& b, vector_type& x) const;
    /** This function applies the matrix @f$ Q^T@f$ encoded in the 
	decomposition to the vector @f$ v@f$, storing the result @f$
	v Q^T@f$ in @f$ v@f$.  The matrix multiplication is carried out
	directly using the encoding of the Householder vectors without
	needing to form the full matrix @f$ Q^T@f$.
	@param v On input, the vector @f$ v@f$.  On output the product
	@f$ v Q^T @f$. 
	@return @c true on success. */
    virtual bool qt_multiply(vector_type& v) const;
    /** This function performs a rank-1 update @f$ w v^T@f$ of the. 
	Update a LQ factorisation for @f$ A= L Q@f$,  @f$ A' = A + v
	u^T@f$, 
	@f{eqnarray*}
	L' Q' = LQ + v u^T\\
	      = (L + v u^T Q^T) Q\\
	      = (L + v w^T) Q
	@f}      
	@f$ where w = Q u@f$.
	Algorithm from Golub and Van Loan, "Matrix Computations",
	Section 12.5 (Updating Matrix Factorizations, Rank-One
	Changes).  */
    virtual bool update(const vector_type& w, const vector_type& v);
    /** This function applies the matrix @f$ Q@f$ encoded in the 
	decomposition to the vector @f$ v@f$, storing the result @f$
	v Q @f$ in @f$ v@f$.  The matrix multiplication is carried out
	directly using the encoding of the Householder vectors without
	needing to form the full matrix @f$ Q@f$.
	@param v On input, the vector @f$ v@f$.  On output the product
	@f$ v Q@f$. 
	@return @c true on success. */
    virtual bool q_multiply(vector_type& v) const;
    /** @return The matrix @f$ R@f$ of the LQ decomposition of @f$
	A@f$ */ 
    const matrix_type& l() const;
    /** @return The matrix @f$ Q@f$ of the LQ decomposition of @f$
	A@f$ */ 
    const matrix_type& q() const;
    /** @return The matrix @f$ LQ@f$ of the LQ decomposition of @f$
	A@f$ */  
    const matrix_type& lq() const;
  protected:
    /** The low level matrix type */
    typedef matrix_type::data_type data_type;
    /** The @f$ tau@f$ of the LQ decomposition */
    vector_type _tau;
    /** The Q of the LQ decomposition of the input matrix */
    mutable matrix_type*  _q;
    /** The R of the LQ decomposition of the input matrix */
    mutable matrix_type*  _l;
    /** Unpack LQ into @f$ Q@f$ and @f$ R@f$. */
    void unpack() const;
    /** Create an LQ decomposition of the input matrix @a m. 
	A reference to the input matrix is stored for later use. */
    lq_decomposition(const matrix_type& m, bool nodo);
  };
  //__________________________________________________________________
  inline
  lq_decomposition<@type@>::lq_decomposition(const matrix_type& m) 
    : matrix_type(m), 
      _tau(std::min(m.row_size(), m.column_size())), 
      _q(0), 
      _l(0)
  {
    int ret = gsl_linalg@low@_LQ_decomp(_matrix, _tau._vector);
    (void)ret;
  }
  //__________________________________________________________________
  inline
  lq_decomposition<@type@>::lq_decomposition(const matrix_type& m, bool) 
    : matrix_type(m), 
      _tau(std::min(m.row_size(), m.column_size())), 
      _q(0), 
      _l(0)
  {}
  //__________________________________________________________________
  inline
  lq_decomposition<@type@>::~lq_decomposition() 
  {
    if (_q) delete _q;
    if (_l) delete _l;
  }
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::solve(const vector_type& b, vector_type& x) const
  {
    int ret = gsl_linalg@low@_LQ_solve_T(_matrix, _tau._vector, 
					 b._vector, x._vector);
    return (ret == 0);
  }  
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::solve(vector_type& x) const
  {
    int ret = gsl_linalg@low@_LQ_svx_T(_matrix, _tau._vector, x._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::solve(const vector_type& b, vector_type& x, 
				  vector_type& r) const
  {
    int ret = gsl_linalg@low@_LQ_lssolve_T(_matrix, _tau._vector, 
					   b._vector, x._vector, r._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::l_solve(const vector_type& b, 
				    vector_type& x) const
  {
    int ret = gsl_linalg@low@_LQ_Lsolve_T(_matrix, b._vector, x._vector);
    return ret == 0;
  }
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::l_solve(vector_type& x) const
  {
    int ret = gsl_linalg@low@_LQ_Lsvx_T(_matrix, x._vector);
    return ret == 0;
  }
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::lq_solve(const vector_type& b, 
				     vector_type& x) const
  {
    unpack();
    int ret = gsl_linalg@low@_LQ_LQsolve(_q->_matrix, _l->_matrix, 
					 b._vector, x._vector);
    return ret == 0;
  }      
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::qt_multiply(vector_type& v) const
  {
    int ret = gsl_linalg@low@_LQ_vecQT(_matrix, _tau._vector, v._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::update(const vector_type& w, const vector_type& v)
  {
    vector_type tmp(w);
    int ret = gsl_linalg@low@_LQ_update(q()._matrix, l()._matrix,
					tmp._vector, v._vector);
    return ret == GSL_SUCCESS;
  }
  //__________________________________________________________________
  inline bool
  lq_decomposition<@type@>::q_multiply(vector_type& v) const
  {
    int ret = gsl_linalg@low@_LQ_vecQ(_matrix, _tau._vector, v._vector);
    return (ret == 0);
  }
  //__________________________________________________________________
  inline const lq_decomposition<@type@>::matrix_type&
  lq_decomposition<@type@>::l() const 
  {
    unpack();
    return *_l;
  }
  //__________________________________________________________________
  inline const lq_decomposition<@type@>::matrix_type&
  lq_decomposition<@type@>::q() const 
  {
    unpack();
    return *_q;
  }
  //__________________________________________________________________
  inline const lq_decomposition<@type@>::matrix_type&
  lq_decomposition<@type@>::lq() const
  {
    return *this;
  }
  //__________________________________________________________________
  inline void
  lq_decomposition<@type@>::unpack() const
  {
    if (_l) return;
    _q = new matrix_type(column_size(), column_size());
    _l = new matrix_type(row_size(), column_size());
    gsl_linalg@low@_LQ_unpack(_matrix, _tau._vector, 
			      _q->_matrix, _l->_matrix);
  }
}

#endif
//____________________________________________________________________
//
// EOF
//
  
