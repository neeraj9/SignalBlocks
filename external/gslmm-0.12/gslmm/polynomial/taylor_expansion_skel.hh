//
// $Id: taylor_expansion_skel.hh,v 1.8 2006-02-08 00:08:31 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::taylor_expansion@name@.hh
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_taylor_expansion@name@
#define GSLMM_taylor_expansion@name@
#ifndef GSLMM_taylor_expansion_base
#include <gslmm/polynomial/taylor_expansion_base.hh>
#endif  
#ifndef GSLMM_divide_difference@name@
#include <gslmm/divide_difference@name@.hh>
#endif

/** @file   taylor_expansion@name@.hh
    @author Christian Holm
    @date   Sat Mar 08 18:31:32 2003
    @brief  Representation of a tayler expansion */

namespace gslmm
{
  /** @brief Representation of a tayler expansion - @c @type@ specialisation
      @ingroup polynomial
  */
  template <>
  class taylor_expansion<@type@> : public polynomial<@type@>
  {
  public:
    /// The type of the return values. 
    typedef polynomial<@type@>::value_type    value_type;
    /// The type of the argument values. 
    typedef polynomial<@type@>::argument_type argument_type;
  protected:
    /// The value expanded about 
    argument_type _x0;
  public:
    /** Workspace class for conversion from divide_difference
	representation. */
    class workspace 
    {
    private:
      workspace(const workspace&) : _ws(0) {}
      workspace& operator=(const workspace&) { return * this; }
    public:
      /// The actual data 
      @type@* _ws;
      /// CTOR.  Allocate the needed memory.
      workspace(size_t n) :_ws(0) { _ws = new @type@[n]; }
      /// DTOR Deallocate the memory. 
      ~workspace() { delete [] _ws; }
    };
    
    /** Constructor. */
    taylor_expansion(argument_type x0, const value_type* p, size_t n);
    /** Constructor. */
    taylor_expansion(argument_type x0, const std::vector<value_type>& p);
    /** Constructor. */
    taylor_expansion(argument_type x0, 
		     const value_type p0,   const value_type p1,   
		     const value_type p2=0, const value_type p3=0, 
		     const value_type p4=0, const value_type p5=0, 
		     const value_type p6=0, const value_type p7=0,
		     const value_type p8=0, const value_type p9=0);
    /** Constructor */
    taylor_expansion(argument_type x0,
		     const divide_difference<value_type>& dd);
    /** Constructor */
    taylor_expansion(argument_type x0, 
		     const divide_difference<value_type>& dd, workspace& w);
    /** Destructor. */
    virtual ~taylor_expansion() {}

    /** Get the expansion point. */
    argument_type expansion_point() const { return _x0; }
    /** Set the expansion point. */
    argument_type expansion_point(argument_type x0) { return _x0 = x0; }

    /** Evaluate the polynomial */
    value_type evaluate(const argument_type& x);  
  };

  //__________________________________________________________________
  inline
  taylor_expansion<@type@>::taylor_expansion(const argument_type x0, 
					     const value_type p0, 
					     const value_type p1,   
					     const value_type p2, 
					     const value_type p3, 
					     const value_type p4, 
					     const value_type p5, 
					     const value_type p6, 
					     const value_type p7, 
					     const value_type p8, 
					     const value_type p9)
    : polynomial<@type@>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9),_x0(x0)
  {}
  //__________________________________________________________________
  inline
  taylor_expansion<@type@>::taylor_expansion(const argument_type x0, 
					     const value_type* p,
					     size_t n) 
    : polynomial<@type@>(p, n), _x0(x0)
  {}
  //__________________________________________________________________
  inline
  taylor_expansion<@type@>::taylor_expansion(const argument_type x0, 
					     const std::vector<value_type>& p) 
    : polynomial<@type@>(p), _x0(x0)
  {}
  //__________________________________________________________________
  inline
  taylor_expansion<@type@>::taylor_expansion(const argument_type x0, 
					     const divide_difference<value_type>& dd)
    :  polynomial<@type@>(dd.size()), _x0(x0)
  {
    if (_p.size() != dd.size()) return;
    workspace w(_p.size());
    gsl_poly@low@_dd_taylor(&(_p[0]), _x0, dd.dd(), 
			    dd.xa(), dd.size(), w._ws);
  }
  //__________________________________________________________________
  inline
  taylor_expansion<@type@>::taylor_expansion(const argument_type x0, 
					     const divide_difference<value_type>& dd,
					     workspace& w)
    : polynomial<@type@>(dd.size()), _x0(x0)
  {
    std::cout << "calling gsl_poly@low@_dd_taylor" << std::endl;
    gsl_poly@low@_dd_taylor(&(_p[0]), _x0, dd.dd(), 
			    dd.xa(), dd.size(), w._ws);
  }
  //__________________________________________________________________
  inline @type@
  taylor_expansion<@type@>::evaluate(const argument_type& x) 
  {
    return polynomial<value_type>::evaluate(x - _x0);
  }
}

#endif
//____________________________________________________________________
//
// EOF
//
