//
// $Id: polynomial_skel.hh,v 1.12 2006-04-19 09:32:46 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::polynomial@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_polynomial@name@
#define GSLMM_polynomial@name@
#line 29 "polynomial_skel.hh"
/** @file   polynomial@name@.hh
    @author Christian Holm
    @date   Sat Mar 01 02:16:43 2003
    @brief  Polynomial - @type@ specialisations */

#ifndef GSL_polynomial_base
#include <gslmm/polynomial/polynomial_base.hh>
#endif  
#ifndef GSL_util
#include <gslmm/gslmm-util.hh>
#endif
#ifndef __GSL_POLY_H__
#include <gsl/gsl_poly.h>
#endif
#ifndef __GSL_ERRNO_H__
#include <gsl/gsl_errno.h>
#endif
#ifndef GSLMM_complex@name@
#include <gslmm/compleks/complex@name@.hh>
#endif
namespace gslmm
{
  //==================================================================
  /** A polynomial in 1 dimension. @type@ specialisation 
      @ingroup polynomial
  */
  template <>
  class polynomial<@type@> // : public function_1d<@type@>
  {
  public:
    /// The type of the return values. 
    typedef @type@ value_type;
    /// The type of the argument values. 
    typedef @type@ argument_type;
  protected:
    /// The coefficents of the polynomial 
    std::vector<value_type> _p;
  private:
    /// Private method for complex solve of order 1, 2, and 3
    size_t solve123(complex<value_type>* z);
  public:
    /** Class to hold a workspace for root-finding. */
    class workspace 
    {
    private:
      /// The low-level work-space data
      gsl_poly_complex_workspace@low@* _ws;
      // make the polynomial class a friend, so we can access the
      // @code _ws member directly
      friend class polynomial<@type@>;
      /// Protected CTOR
      workspace(const workspace&) : _ws(0) {}
      /// Protected assignment 
      workspace& operator=(const workspace&) { return *this; }
    public:
      /** CTOR
	  @param n size of the workspace.  It should be the size
	  of the polynomial plus one.  That is, if you're indenting to
	  solve a polynomial of size 4, @a n should be 5. */
      workspace(size_t n);
      /** CTOR.  This one automatically gets' the right size. */
      workspace(const polynomial<@type@>& p);
      /// DTOR.
      ~workspace();
    };

    /** Constructor. */
    polynomial() {}
    /** Constructor. */
    polynomial(size_t n) : _p(n) {}
    /** Constructor. */
    polynomial(const value_type* p, size_t n) : _p(n) { coefficents(p,n); }
    /** Constructor. */
    polynomial(const std::vector<value_type>& p) : _p(p.size()) 
    { 
      coefficents(&(p[0]),p.size()); 
    }
    /** Constructor. */
    polynomial(const value_type p0,   const value_type p1,   
	       const value_type p2=0, const value_type p3=0, 
	       const value_type p4=0, const value_type p5=0, 
	       const value_type p6=0, const value_type p7=0, 
	       const value_type p8=0, const value_type p9=0);
    /** Destructor. */
    virtual ~polynomial() {}

    /** Evaluate the polynomial */
    value_type evaluate(const argument_type& x);
    /** Evaluate the derivative of the polynomial */
    value_type derivative(const argument_type& x);

    /** Get the size of the polynomial.  That is, the size
	of @f$ p(x) = p_0 + p_1x + p_2x^2 @f$ is 2. */
    size_t size() const { return _p.size() - 1; }

    /** Set the coefficents of the polynomial. */
    const std::vector<value_type>& coefficents(const value_type* p, size_t n);
    /** Set the coefficents of the polynomial. */
    const std::vector<value_type>& coefficents(const 
					       std::vector<value_type>& p);
    /** Set the coefficents of the polynomial. */
    const std::vector<value_type>& coefficents(const value_type p0,   
					       const value_type p1,   
					       const value_type p2=0, 
					       const value_type p3=0, 
					       const value_type p4=0, 
					       const value_type p5=0, 
					       const value_type p6=0, 
					       const value_type p7=0, 
					       const value_type p8=0, 
					       const value_type p9=0);    
    /** Get the coefficents */
    const std::vector<value_type> coefficents() const { return _p; }
    /** Set a coefficent */ 
    value_type coefficent(size_t i, const value_type& c) { return _p[i] = c; }
    /** Get a coefficent */
    value_type coefficent(size_t i) const { return _p[i]; }

    /** Find the real roots of this polynomial. 
	@param x array to store the roots in.  It must be at least as
	big as the size plus 1 of the polynomial. 
	@return the number of roots found. */
    size_t solve(value_type* x);
    /** Find the complex roots of this polynomial. 
	This allocates the needed workspace itself.  If that's not
	optimial (because you want to reuse the memory), then you
	should use the other solve function, that does take a
	workspace argument. 
	@param x array to store the roots in.  It must be at least as
	big as the size plus 1 of the polynomial. 
	@return the number of roots found. */
    size_t solve(complex<value_type>* x);
    /** Find the complex roots of this polynomial. 
	@param x array to store the roots in.  It must be at least as
	@param w The workspace to use (allowing for reuse). 
	big as the size plus 1 of the polynomial. 
	@return the number of roots found. */
    size_t solve(complex<value_type>* x, workspace& w);
  };
  //__________________________________________________________________
  inline
  polynomial<@type@>::polynomial(const value_type p0, const value_type p1,   
				 const value_type p2, const value_type p3, 
				 const value_type p4, const value_type p5, 
				 const value_type p6, const value_type p7, 
				 const value_type p8, const value_type p9)
    : _p(1)
  {
    coefficents(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
  }
  //__________________________________________________________________
  inline @type@
  polynomial<@type@>::evaluate(const argument_type& x) 
  {
    return gsl_poly@low@_eval(&(_p[0]), _p.size(), x);
  }
  //__________________________________________________________________
  inline @type@
  polynomial<@type@>::derivative(const argument_type& x) 
  {
    std::vector<value_type> dp(_p.size()-1);
    for (size_t i = 1; i < _p.size(); i++) dp[i-1] = _p[i] * i;
    return gsl_poly@low@_eval(&(dp[0]), dp.size(), x);
  }
  //__________________________________________________________________
  inline const std::vector<@type@>& 
  polynomial<@type@>::coefficents(const value_type* p, size_t n) 
  { 
    _p.resize(n,0);
    for (size_t i = 0; i < n; i++)  _p[i] = p[i];
    return _p;
  }
  //__________________________________________________________________
  inline const std::vector<@type@>& 
  polynomial<@type@>::coefficents(const std::vector<value_type>&  p) 
  { 
    _p = p;
    return _p;
  }
  //__________________________________________________________________
  inline const std::vector<@type@>& 
  polynomial<@type@>::coefficents(const value_type p0, const value_type p1,
				  const value_type p2, const value_type p3, 
				  const value_type p4, const value_type p5, 
				  const value_type p6, const value_type p7, 
				  const value_type p8, const value_type p9)
  {
    std::vector<@type@> p(10);
    p[0] = p0;  p[1] = p1; p[2] = p2; p[3] = p3; p[4] = p4;
    p[5] = p5;  p[6] = p6; p[7] = p7; p[8] = p8; p[9] = p9;
    int i = 9;
    for (i = 9; i >= 0; i--) if (p[i] != 0) break;
    return coefficents(&(p[0]), size_t(i+1));
  }
  //__________________________________________________________________
  inline size_t
  polynomial<@type@>::solve(value_type* x) 
  {
    if (size() == 1) { 
      x[0] = -_p[0] / _p[1];
      return 1;
    }
    if (size() == 2) {
      size_t n = gsl_poly@low@_solve_quadratic(_p[2],_p[1],_p[0], 
						 &(x[0]), &(x[1]));
      return n;
    }
    if (size() == 3) 
      return gsl_poly@low@_solve_cubic(_p[2]/_p[3],_p[1]/_p[3],
					    _p[0]/_p[3], &(x[0]), &(x[1]),
					    &(x[2]));
    return 0;
  }

  //__________________________________________________________________
  inline size_t
  polynomial<@type@>::solve123(complex<value_type>* z) 
  {
    if (size() == 1) {
      z[0].real() = -_p[0]/_p[1];
      z[0].imag() = 0;
      return 1;
    }
    if (size() == 2) {
      gsl_complex@low@ z0, z1;
      size_t n = 
	gsl_poly@low@_complex_solve_quadratic(_p[2],_p[1],_p[0], 
						   &z0, &z1);
      z[0].real() = GSL_REAL(z0); z[0].imag() = GSL_IMAG(z0);
      z[1].real() = GSL_REAL(z1); z[1].imag() = GSL_IMAG(z1);
      return n;
    }
    if (size() == 3) {
      gsl_complex@low@ z0, z1, z2;
      size_t n = 
	gsl_poly@low@_complex_solve_cubic(_p[2]/_p[3],_p[1]/_p[3],
					       _p[0]/_p[3], &z0, &z1, &z2);
      z[0].real() = GSL_REAL(z0); z[0].imag() = GSL_IMAG(z0);
      z[1].real() = GSL_REAL(z1); z[1].imag() = GSL_IMAG(z1);
      z[2].real() = GSL_REAL(z2); z[2].imag() = GSL_IMAG(z2);
      return n;
    }
    return 0;
  }
    
  //__________________________________________________________________
  inline size_t
  polynomial<@type@>::solve(complex<value_type>* z) 
  {
    if (size() <= 3) return solve123(z);
    workspace* w = new workspace(*this);
    size_t n = solve(z, *w);
    delete w;
    return n;
  }

  //__________________________________________________________________
  inline size_t
  polynomial<@type@>::solve(complex<value_type>* z, workspace& w) 
  {
    if (size() <= 3) return solve123(z);
    std::vector<@type@> zz(2*(size()+1));
    size_t r = 
      gsl_poly@low@_complex_solve(&(_p[0]), _p.size(), w._ws, &(zz[0]));
    if (r == GSL_SUCCESS) {
      r = size();
      for (size_t i = 0; i < r; i++) {
	z[i].real() = zz[2*i]; 
	z[i].imag() = zz[2*i+1];
      }
    }
    else 
      r = 0;
    return r;
  }

  //__________________________________________________________________
  inline polynomial<@type@>::workspace::workspace(size_t n) 
    : _ws(0) 
  { 
    // _ws = new gsl_poly_complex_workspaceL);
    // _ws->nc = n-1;
    // _ws->matrix = new T[_ws->nc*_ws->nc];
    _ws = gsl_poly@low@_complex_workspace_alloc(n); 
  }
  //__________________________________________________________________
  inline polynomial<@type@>::workspace::workspace(const polynomial<@type@>& p) 
    : _ws(0)
  { 
    // _ws = new gsl_poly_complex_workspaceL);
    // _ws->nc = p.size();
    // _ws->matrix = new T[_ws->nc*_ws->nc];
    _ws = gsl_poly@low@_complex_workspace_alloc(p.size()+1); 
  }
  //__________________________________________________________________
  inline polynomial<@type@>::workspace::~workspace() 
  { 
    // delete [] _ws->matrix;
    // delete _ws;
    gsl_poly@low@_complex_workspace_free(_ws); 
  }
}

#endif
//____________________________________________________________________
//
// EOF
//
