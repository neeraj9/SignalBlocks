//
// $Id: matrix_skel.hh,v 1.22 2007-04-21 09:03:14 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::matrix@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_matrix@name@
#define GSLMM_matrix@name@
#line 29 "matrix_skel.hh"
/** @file   matrix@name@.hh
    @author Christian Holm
    @date   Mon Mar 10 14:50:12 2003
    @brief  @c @type@ specialisation of matrix class */

#ifndef GSLMM_matrix_base
# include <gslmm/vectormatrix/matrix_base.hh>
#endif
#ifndef _GSL_MATRIX_H_
# include <gsl/gsl_matrix.h>
#endif
#ifndef GSLMM_vectormatrix_vector@name@
# include <gslmm/vectormatrix/vector@name@.hh>
#endif
#if @complex@
# ifndef GSLMM_@cname@
#  include <gslmm/compleks/@cname@.hh>
# endif
#endif
#ifndef GSLMM_math_type_trait
# include <gslmm/math/type_trait.hh>
#endif

namespace gslmm
{
  /** @brief Matrix @c @type@ specialisation.
      @ingroup matrix
   */
  template <>
  class matrix<@type@>
  {
  public:
    /** Size type. */
    typedef size_t size_type;
    /** Iterator (or indexer) type. */
    typedef size_t iterator;
    /** Type of data */
    typedef @type@ value_type;
    /** Type of data */
    typedef @sub@ element_type;
    /** Low level data type */
    typedef gsl_matrix@low@ data_type;
    /** Low level view type */
    typedef gsl_matrix@low@_view view_type;
    /** Type of associated vectors */
    typedef vector<value_type> vector_type;
    /** Type of traits for elements */
    typedef type_trait<value_type> trait_type;
    /** Type of reference */
    typedef trait_type::reference_type reference_type;
    /** Type of return value */
    typedef matrix_return<value_type> return_type;
    /** Type of passed return type */
    typedef std::auto_ptr<return_type> oper_type;

    /** Constructor from a product 
	@param p Product */
    matrix(oper_type p);
    /** Constructor. 
	@param rows Number of rows in matrix. 
	@param columns Number of columns in matrix. 
	@param zero If true initialise to zero (null) matrix. */
    matrix(size_t rows, size_t columns, bool zero=true);
#if @complex@
    /** Copy constructor. 
	@param m The matrix to copy. 
	@param trans If true, the transpose of @a m is copied to this
	object.
	@param conj If true, also conjugate the matrix. */
    matrix(const matrix<value_type>& m, bool trans=false, bool conj=false);
#else
    /** Copy constructor. 
	@param m The matrix to copy. 
	@param trans If true, the transpose of @a m is copied to 
	@c this. */
    matrix(const matrix<value_type>& m, bool trans=false);
#endif
    /** View constructor.
	@param m Matrix to create view from,
	@param row_offset Offset in row direction, 
	@param column_offset Offset in column direction,
	@param rows Rows in view
	@param columns Columns in view. 
	@param tda If positive, the physical number of columns in
	memory. */
    matrix(const matrix<value_type>& m, 
	   iterator row_offset, iterator column_offset, 
	   size_type rows, size_type columns, size_type tda=0);
    /** View constructor.
	@param array Array to create view from,
	@param rows Rows in view
	@param columns Columns in view. 
	@param tda If positive, the physical number of columns in
	memory. */
    matrix(element_type* array, size_type rows, size_type columns, 
	   size_type tda=0);
    /** View constructor.
	@param v Vector to create view from,
	@param rows Rows in view
	@param columns Columns in view. 
	@param tda If positive, the physical number of columns in
	memory. */
    matrix(const vector_type& v, 
	   size_type rows, size_type columns, size_type tda=0);
    /** Destructor.  */
    virtual ~matrix();

    /** @{
	@name Swaping data */
    /** Swap two matricies. */
    void swap(const matrix<value_type>& m);
    /** Swap two rows .*/
    void swap_rows(iterator i, iterator j);
    /** Swap two columns .*/
    void swap_columns(iterator i, iterator j);
    /** Swap row @a i for column @a j. Matrix must be square. */
    void swap_row_column(iterator i, iterator j);
    /** @} */
    

    /** @{
	@name Information */
    /** Get the number of rows. */
    size_type row_size() const { return _matrix->size1; }
    /** Get the number of columns. */
    size_type column_size() const { return _matrix->size2; }
    /** Whether this is the owner of the data. */
    bool is_owner() const; 
    /** Whether this is the null matrix. */
    bool is_null() const;
    /** Get the physical number of columns in memory. */
    size_type tda() const { return _matrix->tda; }
    /** @} */

    /** @{
	@name Manipulations */
    /** Reset all elements to zero */
    void zero();
    /** Set all elements to one number. 
	@param x the value to set all elements to. */
    void set(value_type x);
    /** Make an identity matrix.
       only the @f$ i,i@f$ elements are 1, the rest of the elements
       are zero.  */
    void identity();
    /** Make this into the transpose of it self.  This member function
	only works for square matricies. */
    void transpose();
#if @complex@
    /** Conjugate all elements of the matrix. */
    void conjugate();
#endif
    /** @} */

    /** @{ 
	@name Member access */
    /** Member accessor. 
	@param row The row number 
	@param column The column number 
	@return the @f$ i,j@f$-th element. */
    const reference_type operator()(iterator row, iterator column) const;
    /** Member accessor. 
	@param row The row number 
	@param column The column number 
	@return the @f$ i,j@f$-th element. */
    reference_type operator()(iterator row, iterator column);
    /** Get a row. 
	@param r The row number to get (starts at 0) 
	@return the @a r row of the matrix, as a reference only */
    vector_type operator[](iterator r);
    /** Get a row (const version).
	@param r The row number to get (starts at 0)
	@return the @a r row of the matrix, as a reference only */
    const vector_type operator[](iterator r) const;
    /** Get a pointer to the element at (@a row, @a col) 
	@param row Row number 
	@param column Column number 
	@return pointer to element (@a i, @a j) */
    value_type* element(iterator row, iterator column);
    /** Get a pointer to the element at (@a row, @a col) 
	@param row Row number 
	@param column Column number 
	@return pointer to element (@a i, @a j) */
    const value_type* element(iterator row, iterator column) const;
    /** @} */

    /** @{
	@name Views of all kinds */
    /** Get a sub-matrix of this matrix. 
	@param row Row in this matrix to start at 
	@param column Column in this matrix to start at 
	@param rows Number of rows in sub-matrix 
	@param columns Number of columns in sub-martix. 
	@return a new matrix object that does not own the data. */
    matrix<@type@> operator()(iterator row, iterator column, 
				    size_type rows, size_type columns) const;
    /** Get a row. 
	@param r The row number to get (starts at 0) 
	@return the @a r row of the matrix, as a reference only */
    vector_type row(iterator r);
    /** Get a row (const version).
	@param r The row number to get (starts at 0)
	@return the @a r row of the matrix, as a reference only */
    const vector_type row(iterator r) const;
    /** Get a column. 
	@param c The column number to get (starts at 0)
	@return the @a c column of the matrix, as a reference only */
    vector_type column(iterator c);
    /** Get a column (const version).
	@param c The column number to get (starts at 0)
	@return the @a c column of the matrix, as a reference only */
    const vector_type column(iterator c) const;
    /** Get the diagonal. 
	@param d The diagonal number.  Negative are below diagonal,
	positive above, and zero is the diagonal itself.
	@return the diagonal of the matrix, as a reference only */
    vector_type diagonal(int d);
    /** Get the diagonal (const version).
	@param d The diagonal number.  Negative are below diagonal,
	positive above, and zero is the diagonal itself.
	@return the diagonal of the matrix, as a reference only */
    const vector_type diagonal(int d) const;
    /** Get a sub-diagonal. 
	@param s The sub-diagonal number to get (0 is diagonal)
	@return the @a s sub-diagonal of the matrix, as a reference only */
    vector_type sub_diagonal(int s);
    /** Get a sub-diagonal (const version).
	@param s The sub-diagonal number to get (0 is the diagonal)
	@return the @a s sub-diagonal of the matrix, as a reference only */
    const vector_type sub_diagonal(int s) const;
    /** Get a super-diagonal. 
	@param s The super-diagonal number to get (0 is diagonal)
	@return the @a s super-diagonal of the matrix, as a reference only */
    vector_type super_diagonal(int s);
    /** Get a super-diagonal (const version).
	@param s The super-diagonal number to get (0 is the diagonal)
	@return the @a s super-diagonal of the matrix, as a reference only */
    const vector_type super_diagonal(int s) const;
    /** @} */

    /** @{
	@name Assignment operations */
    /** Assignment operator */
    matrix<value_type>& 
    operator=(const matrix<value_type>& m);
    /** Assignment operator */
    matrix<value_type>& 
    operator=(oper_type m);
    /** Add a matrix, element by element
	@param o The matrix to add to @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}+o_{ij}@f$ */
    matrix<value_type>& 
    operator+=(const matrix<value_type>& o);
    /** Subtract a matrix, element by element
	@param o The matrix to subtract from @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}-o_{ij}@f$ */
    matrix<value_type>& 
    operator-=(const matrix<value_type>& o);
    /** Multiply by a matrix, element by element
	@param o The matrix to multiply to @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}o_{ij}@f$ */
    matrix<value_type>& 
    operator*=(const matrix<value_type>& o);
    /** Divide by a matrix, element by element
	@param o The matrix to divide into @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}/o_{ij}@f$ */
    matrix<value_type>& 
    operator/=(const matrix<value_type>& o);
    /** Add a number to all elements
	@param o The number to add to @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}+o@f$ */
    matrix<value_type>& operator+=(const value_type& o);
    /** Subtract a number from all elements
	@param o The number to subtract from @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}-o@f$ */
    matrix<value_type>& operator-=(const value_type& o);
    /** Multiply all elements by a number.
	@param o The number to multiply to @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}o@f$ */
    matrix<value_type>& operator*=(const value_type& o);
    /** Divide all elements by a number
	@param o The number to divide into @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}/o@f$ */
    matrix<value_type>& operator/=(const value_type& o);
    /** @} */

#if @complex@
#else
    /** @{ 
	@name Minimum and maximum elemens */
    /** Find the smallest value in matrix. 
	@return the smallest element in matrix. */
    value_type min() const;
    /** Find the largest value in matrix. 
	@return the largest element in matrix. */
    value_type max() const;
    /** Find the smallest and largest values in matrix.
	@param min Smallest element in matrix.
	@param max Largest element in matrix. */
    void minmax(value_type& min, value_type& max) const;
    /** Find the position of the smallest value in matrix. 
	@param row Row index of smallest element in matrix.
	@param column Column index of smallest element in matrix. */
    void min_index(iterator& row, iterator& column) const;
    /** Find the position of the largest value in matrix. 
	@param row Row index of largest element in matrix.
	@param column Column index of largest element in matrix. */
    void max_index(iterator& row, iterator& column) const;
    /** Find the positions of the smallest and largest values in matrix.
	@param min_row Rows index of the smallest element in matrix.
	@param min_column Column index of the smallest element in matrix. 
	@param max_row Rows index of the largest element in matrix.
	@param max_column Column index of the largest element in matrix. */
    void minmax_index(iterator& min_row, iterator& min_column,
		      iterator& max_row, iterator& max_column) const;
    /** @} */
#endif
    /** The data */
    data_type* _matrix;
  protected:
    /** Construct from a view */
    void from_view(view_type&  view);
    /** Constructor. */
    matrix() : _matrix(0) {}
  };
}

namespace gslmm
{
  //__________________________________________________________________
  inline matrix<@type@>::matrix(oper_type p) 
    : _matrix(0)
  {
    assert(p.get());
    if (!p.get()) GSL_ERROR_VOID("NULL return passed", GSL_EINVAL);
    _matrix = gsl_matrix@low@_calloc(p->row_size(), p->column_size());
    p->operator()(*this);
    // delete p;
    // p = 0;
  }

  //__________________________________________________________________
  inline matrix<@type@>::matrix(size_t rows, size_t columns, bool zero) 
    : _matrix(0)
  {
    if (zero) _matrix = gsl_matrix@low@_calloc(rows, columns);
    else      _matrix = gsl_matrix@low@_alloc(rows, columns);
  }
  //__________________________________________________________________
  inline matrix<@type@>::matrix(const matrix<value_type>& m,
				bool trans
#if @complex@
				, bool conj
#endif
				) 
    : _matrix(0)
  {
    if (!trans) {
      _matrix = gsl_matrix@low@_alloc(m.row_size(), m.column_size());
      *this = m;
    }
    else {
      _matrix = gsl_matrix@low@_alloc(m.column_size(), m.row_size());
      gsl_matrix@low@_transpose_memcpy(_matrix,m._matrix);
    }
#if @complex@
    if (conj) conjugate();
#endif
  }
  
  //__________________________________________________________________
  inline 
  matrix<@type@>::matrix(const matrix<value_type>& m, 
			 iterator row_offset, iterator column_offset, 
			 size_type rows, size_type columns, 
			 size_type) 
    : _matrix(0)
  {
    view_type v = gsl_matrix@low@_submatrix(m._matrix,
					    row_offset, 
					    column_offset,
					    rows, columns);
    from_view(v);
  }
  //__________________________________________________________________
  inline matrix<@type@>::matrix(element_type* array, 
				size_type rows, size_type columns, 
				size_type tda) 
    : _matrix(0)
  {
    view_type v;
    if (tda <= 0)
      v = gsl_matrix@low@_view_array(array, rows, columns);
    else 
      v = gsl_matrix@low@_view_array_with_tda(array, rows, columns, tda);
    from_view(v);
  }
  //__________________________________________________________________
  inline 
  matrix<@type@>::matrix(const vector_type& vec,
			 size_type rows, size_type columns, 
			 size_type tda) 
     : _matrix(0)
 {
    view_type v;
    if (tda <= 0)
      v = gsl_matrix@low@_view_vector(vec._vector, rows, columns);
    else 
      v = gsl_matrix@low@_view_vector_with_tda(vec._vector, rows, 
							columns, tda);
    from_view(v);
  }
  
  //__________________________________________________________________
  inline matrix<@type@>::~matrix()
  {
    gsl_matrix@low@_free(_matrix);
  }
  //__________________________________________________________________
  inline void matrix<@type@>::from_view(view_type& v)
  {
    _matrix = static_cast<data_type*>(malloc(sizeof(data_type)));
    _matrix->size1 = v.matrix.size1;
    _matrix->size2 = v.matrix.size2;
    _matrix->tda   = v.matrix.tda;
    _matrix->data  = v.matrix.data;
    _matrix->block = v.matrix.block;
    _matrix->owner = v.matrix.owner;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator=(const matrix<value_type>& m)
  {
    gsl_matrix@low@_memcpy(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator=(oper_type p)
  {
    assert(p.get());
    if (!p.get()) GSL_ERROR_VAL("NULL return passed", GSL_EINVAL, *this);
    p->operator()(*this);
    return *this;
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::swap(const matrix<value_type>& m)
  {
    gsl_matrix@low@_swap(_matrix,m._matrix);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::swap_rows(iterator i, iterator j)
  {
    gsl_matrix@low@_swap_rows(_matrix,i, j);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::swap_columns(iterator i, iterator j)
  {
    gsl_matrix@low@_swap_columns(_matrix,i, j);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::swap_row_column(iterator i, iterator j)
  {
    gsl_matrix@low@_swap_rowcol(_matrix,i, j);
  }
  //__________________________________________________________________
  inline bool
  matrix<@type@>::is_owner()  const
  {
    return _matrix->owner == 1;
  }
  //__________________________________________________________________
  inline bool
  matrix<@type@>::is_null()  const 
  {
    return gsl_matrix@low@_isnull(_matrix) == 1;
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::zero() 
  {
    gsl_matrix@low@_set_zero(_matrix);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::set(value_type x) 
  {
    gsl_matrix@low@_set_all(_matrix, x);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::identity()
  {
    gsl_matrix@low@_set_identity(_matrix);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::transpose()
  {
    gsl_matrix@low@_transpose(_matrix);
  }
  //__________________________________________________________________
  inline matrix<@type@>
  matrix<@type@>::operator()(iterator i, iterator j, size_type n1, 
				   size_type n2) const
  {
    return matrix<@type@>(*this, i, j, n1, n2);
  }
  //__________________________________________________________________
  inline 
  const matrix<@type@>::reference_type
  matrix<@type@>::operator()(iterator i, iterator j) const 
  {
#if @complex@
    return reference_type(gsl_matrix@low@_ptr(_matrix, i, j));
#else 
    return reference_type(*(gsl_matrix@low@_ptr(_matrix, i, j)));
#endif
  }
  //__________________________________________________________________
  inline 
  matrix<@type@>::reference_type
  matrix<@type@>::operator()(iterator i, iterator j) 
  {
#if @complex@
    return reference_type(gsl_matrix@low@_ptr(_matrix, i, j));
#else 
    return reference_type(*(gsl_matrix@low@_ptr(_matrix, i, j)));
#endif
  }
  //__________________________________________________________________
  inline matrix<@type@>::vector_type
  matrix<@type@>::operator[](iterator i)
  {
    // Must be implemented here - temporary
    return vector_type(gsl_matrix@low@_row(_matrix,i));
  }
  //__________________________________________________________________
  inline const matrix<@type@>::vector_type
  matrix<@type@>::operator[](iterator i) const
  {
    // Must be implemented here - temporary
    return vector_type(gsl_matrix@low@_row(_matrix,i));
  }
  //__________________________________________________________________
  inline matrix<@type@>::value_type*
  matrix<@type@>::element(iterator row, iterator column) 
  {
    // Must be implemented here - temporary
    
    return (value_type*)(gsl_matrix@low@_ptr(_matrix,row, column));
  }
  //__________________________________________________________________
  inline const matrix<@type@>::value_type*
  matrix<@type@>::element(iterator row, iterator column) const
  {
    // Must be implemented here - temporary
    return (value_type*)(gsl_matrix@low@_const_ptr(_matrix,row, column));
  }
  //__________________________________________________________________
  inline matrix<@type@>::vector_type
  matrix<@type@>::row(iterator i)
  {
    return vector_type(gsl_matrix@low@_row(_matrix,i));
  }
  //__________________________________________________________________
  inline const matrix<@type@>::vector_type
  matrix<@type@>::row(iterator i) const
  {
    return vector_type(gsl_matrix@low@_row(_matrix,i));
  }
  //__________________________________________________________________
  inline matrix<@type@>::vector_type
  matrix<@type@>::column(iterator i)
  {
    return vector_type(gsl_matrix@low@_column(_matrix,i));
  }
  //__________________________________________________________________
  inline const matrix<@type@>::vector_type
  matrix<@type@>::column(iterator i) const
  {
    return vector_type(gsl_matrix@low@_column(_matrix,i));
  }
  //__________________________________________________________________
  inline matrix<@type@>::vector_type
  matrix<@type@>::diagonal(int i)
  {
    if (i == 0)     
      return vector_type(gsl_matrix@low@_diagonal(_matrix));
    else if (i < 0) 
      return 
	vector_type(gsl_matrix@low@_subdiagonal(_matrix,-i));
    return 
      vector_type(gsl_matrix@low@_superdiagonal(_matrix,i));
  }
  //__________________________________________________________________
  inline const matrix<@type@>::vector_type
  matrix<@type@>::diagonal(int i) const
  {
    if (i == 0)     
      return vector_type(gsl_matrix@low@_diagonal(_matrix));
    else if (i < 0) 
      return 
	vector_type(gsl_matrix@low@_subdiagonal(_matrix,-i));
    return 
      vector_type(gsl_matrix@low@_superdiagonal(_matrix,i));
  }
  //__________________________________________________________________
  inline matrix<@type@>::vector_type
  matrix<@type@>::sub_diagonal(int i)
  {
    return diagonal(-i);
  }
  //__________________________________________________________________
  inline const matrix<@type@>::vector_type
  matrix<@type@>::sub_diagonal(int i) const
  {
    return diagonal(-i);
  }
  //__________________________________________________________________
  inline matrix<@type@>::vector_type
  matrix<@type@>::super_diagonal(int i)
  {
    return diagonal(i);
  }
  //__________________________________________________________________
  inline const matrix<@type@>::vector_type
  matrix<@type@>::super_diagonal(int i) const
  {
    return diagonal(i);
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator*=(const matrix<value_type>& m)
  {
    gsl_matrix@low@_mul_elements(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator/=(const matrix<value_type>& m)
  {
    gsl_matrix@low@_div_elements(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator+=(const matrix<value_type>& m)
  {
    gsl_matrix@low@_add(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator-=(const matrix<value_type>& m)
  {
    gsl_matrix@low@_sub(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator+=(const value_type& x)
  {
    gsl_matrix@low@_add_constant(_matrix,x);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator-=(const value_type& x)
  {
    gsl_matrix@low@_add_constant(_matrix,-x);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator*=(const value_type& x)
  {
    gsl_matrix@low@_scale(_matrix,x);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<@type@>&
  matrix<@type@>::operator/=(const value_type& x)
  {
    gsl_matrix@low@_scale(_matrix,x);
    return *this;
  }  
#if @complex@
  //__________________________________________________________________
  inline 
  void
  matrix<@type@>::conjugate() 
  {
    for (size_t row = 0; row < row_size(); row++) {
      for (size_t col = 0; col < column_size(); col++) {
	value_type c  = operator()(row,col);
	value_type cc(c.conjugate());
	operator()(row,col) = cc;
      }
    }
  }
#else
  //__________________________________________________________________
  inline 
  matrix<@type@>::value_type
  matrix<@type@>::min() const 
  {
    return gsl_matrix@low@_min(_matrix);
  }
  //__________________________________________________________________
  inline 
  matrix<@type@>::value_type
  matrix<@type@>::max() const 
  {
    return gsl_matrix@low@_max(_matrix);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::minmax(value_type& min, value_type& max) const 
  {
    return gsl_matrix@low@_minmax(_matrix, &min, &max);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::min_index(iterator& row, iterator& column) const 
  {
    gsl_matrix@low@_min_index(_matrix, &row, &column);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::max_index(iterator& row, iterator& column) const 
  {
    gsl_matrix@low@_max_index(_matrix, &row, &column);
  }
  //__________________________________________________________________
  inline void
  matrix<@type@>::minmax_index(iterator& min_row, iterator& min_column,
			       iterator& max_row, iterator& max_column) 
    const 
  {
    gsl_matrix@low@_minmax_index(_matrix, &min_row, &min_column,
					  &max_row, &max_column);
  }
#endif
}


#endif
//____________________________________________________________________
//
// EOF
//
