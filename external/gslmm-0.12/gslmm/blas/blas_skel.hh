//
// $Id: blas_skel.hh,v 1.19 2008-02-13 15:50:59 cholm Exp $ 
//  
// WARNING: automatically generated by @progname@
//          options: @skel@, @type@.  
//          Do not edit this file.
//
//  gslmm::blas@name@
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_blas_blas@name@
#define GSLMM_blas_blas@name@
#line 29 "blas_skel.hh"
/** @file   blas/blas@name@.hh
    @author Christian Holm
    @date   Mon Mar 10 14:50:12 2003
    @brief  @c @type@ specialisation of blas class */

#ifndef GSLMM_blas_blas_base
# include <gslmm/blas/blas_base.hh>
#endif
#ifndef _GSL_BLAS_H_
# include <gsl/gsl_blas.h>
#endif
#if @complex@
# ifndef GSLMM_compleks_@cname@
#  include <gslmm/compleks/@cname@.hh>
# endif
#endif
#ifndef GSLMM_vectormatrix_vector@name@
# include <gslmm/vectormatrix/vector@name@.hh>
#endif
#ifndef GSLMM_vectormatrix_matrix@name@
# include <gslmm/vectormatrix/matrix@name@.hh>
#endif

namespace gslmm
{
  //==================================================================
  // BLAS Level 1
  /** @defgroup blas_lvl1@name@ Specialised for @type@
      @ingroup blas_lvl1 
  */
  //____________________________________________________________________
  /** Compute the inner product of two vectors.  
      That is @f$ v^T u@f$.  However, if the vectors are complex, and
      if @a herm is @c true then @f$ v^H u@f$ is returned. 
      @ingroup blas_lvl1@name@
      @param v first vector 
      @param u second vector 
      @param herm Whether the first vector is hermitian conjugated 
      @return  @f$ v^T u@f$ or @f$ v^H u@f$, if @a herm is @c true */
  template <>
  inline 
  vector<@type@>::value_type
  dot(const vector<@type@>& v, const vector<@type@>& u, bool herm) 
  {
    @type@ r;
    int re;
#if @complex@
    if (herm) 
      re = gsl_blas_@btype@dotu(v._vector, u._vector, r._complex);
    else
      re = gsl_blas_@btype@dotc(v._vector, u._vector, r._complex);
#else 
    (void)herm;
    re = gsl_blas_@btype@dot(v._vector, u._vector, &r);
#endif  
    return r;
  }

  //____________________________________________________________________
  /** Compute the Euclidean norm of the vector @a v 
      @f$ ||v||_2 = \sqrt {\sum v_i^2}@f$ or 
      @f$ ||v||_2 = \sqrt {\sum (\Re(v_i)^2 + \Im(v_i)^2)} @f$
      @ingroup blas_lvl1@name@
      @param v The vector to compute the norm of
      @return  The Euclidean norm, or 2-norm */
  template <>
  inline 
  vector<@type@>::value_type
  norm(const vector<@type@>& v) 
  {
    return gsl_blas_@btype1@@btype@nrm2(v._vector);
  }

  //____________________________________________________________________
  /** Compute the aboslute sum of the vector @a v 
      @f$ \sum |v_i|@f$ or 
      @f$ \sum |\Re(v_i)| + |v_i| @f$
      @ingroup blas_lvl1@name@
      @param v The vector to absolute sum of
      @return  The absolute sum, or 1-norm */
  template <>
  inline 
  vector<@type@>::element_type
  absolute_sum(const vector<@type@>& v) 
  {
    return gsl_blas_@btype1@@btype@asum(v._vector);
  }
  
  //____________________________________________________________________
  /** These functions return the index of the largest element of the
      vector @a v. The largest element is determined by its absolute 
      magnitude for real vector and by the sum of the magnitudes of
      the real and imaginary parts @f$ |\Re(v_i)| + |\Im(v_i)| @f$ for
      complex vectors.  If the largest value occurs several times then
      the index of the first occurrence is returned.  
      @ingroup blas_lvl1@name@
      @param v 
      @return Index @f$ i@f$ where @f$ v_i@f$ is the largest element
      in the vector */
  template <>
  inline 
  gslmm::vector<@type@>::iterator
  max(const gslmm::vector<@type@>& v) 
  {
    return gsl_blas_i@btype@amax(v._vector);
  }

  //____________________________________________________________________
  /** exchange the elements of the vectors @a v and @a u
      @ingroup blas_lvl1@name@
      @param v First vector 
      @param u Second vector  */
  template <>
  inline 
  void
  swap(vector<@type@>& v, vector<@type@>& u) 
  {
    int re = gsl_blas_@btype@swap(v._vector, u._vector);
    (void)re;
  }

  //____________________________________________________________________
  /** Copies the vector @a v into the vector @a u
      @ingroup blas_lvl1@name@
      @param u vector to copy to
      @param v vector to copy from */
  template <>
  inline 
  void
  copy(const vector<@type@>& v, vector<@type@>& u) 
  {
    int re = gsl_blas_@btype@copy(v._vector, u._vector);
    (void)re;
  }
  
  //____________________________________________________________________
  /** Compute the sum @f$ u  = a v + u@f$ for the vectors @a u and @a
      v
      @ingroup blas_lvl1@name@
      @param a scale parameter 
      @param v First operand. 
      @param u Second operand.  The vector is overwritten by @f$ a v +
      u@f$  */
  template <>
  inline 
  void
  scaled_add(const @type@& a, const vector<@type@>& v, vector<@type@>& u) 
  {
#if @complex@
    int re = gsl_blas_@btype@axpy(*(a._complex), v._vector, u._vector);
#else
    int re = gsl_blas_@btype@axpy(a, v._vector, u._vector);
#endif
    (void)re;
  }
  
  //____________________________________________________________________
  /** These functions rescale the vector @a v by the multiplicative
      factor @a a
      @ingroup blas_lvl1@name@
      @param a Scale 
      @param v The vector.  It is overwritten by @f$ a v @f$ on
      return. */
  template <>
  inline 
  void
  scale(const @sub@& a, vector<@type@>& v) 
  {
    gsl_blas_@btype@@btype1@scal(a, v._vector);
  }


  //__________________________________________________________________
  /** Form dot product between two vectors
      @ingroup blas_lvl1@name@
      @param w vector to multiply with. 
      @param u vector to multiply with. 
      @return the dot product @f$ r = \sum_i w_i u_i @f$ */
  template <>
  inline @type@
  operator*<@type@>(const vector<@type@>& w, const vector<@type@>& u) 
  {
    return dot(w,u, true);
  }
#if @complex@
#else  
  //____________________________________________________________________
  /** Compute and apply a Givens rotation: 
      @ingroup blas_lvl1@name@
      @f[
         \left(\begin{array}{cc}
	     c  & s \\
	     -s & c
         \end{array}\right)
         \left(\begin{array}{c}
	     a \\ 
	     b
         \end{array}\right)
	 =
         \left(\begin{array}{c}
	     r \\ 
	     0
         \end{array}\right)
       @f]

       The function operator applies this rotation to the vector @f$
       u,v@f$ so that 
      @f[
        v_i = c v_i + s u_i \quad u_i = -s v_i + c u_i
      @f]  */
  template <>
  struct givens_rotation<@type@> : public matrix<@type@>
  {
  public: 
    /** Value type */
    typedef @type@ value_type;
    /** Vector type */
    typedef vector<value_type> vector_type;
    /** Matrix type */
    typedef matrix<value_type> matrix_type;

    /** Generate the givens rotation 
	@param v Vector to zero.  */
    givens_rotation(const vector_type& v) 
      : matrix_type(2,2)
    {
      value_type a = v[0];
      value_type b = v[1];
      int re = gsl_blas_@btype@rotg(&a, &b, &_c, &_s);
      (void)re;
      matrix_type::operator()(0,0) = _c;
      matrix_type::operator()(0,1) = _s;
      matrix_type::operator()(1,0) = -_s;
      matrix_type::operator()(1,1) = _c;
    }
    /** Apply the givens rotation. 
	@param v Vector to apply rotation to 
	@param u Vector to apply rotation to */
    void
    operator()(vector_type& v, vector_type& u) const
    {
      int re = gsl_blas_@btype@rot(v._vector, u._vector, _c, _s);
      (void)re;
    }
  protected:
    /** Default constructor - hidden */
    givens_rotation() : matrix_type(2,2), _c(0), _s(0) { }
    /** givens rotation matrix entry @f$ c@f$ */
    @type@ _c;
    /** givens rotation matrix entry @f$ s@f$ */
    @type@ _s;
  }; 

  //____________________________________________________________________
  /** Compute and apply a modified Givens rotation.  Given @f$ a, b@f$
      in factored form 
      @ingroup blas_lvl1@name@
      @f[ 
        a = \sqrt{d_1} x_1 \quad b = \sqrt{d_2} y_1\quad,
      @f]
      this structure construct the modified Givens plane rotation @f$
      d_1', d_2' @f$ and the matrix @f$ H@f$ such that 
      @f[
         \left(\begin{array}{cc}
	     \sqrt{d_1'}  & 0 \\
	     0            & \sqrt{d_2'}
         \end{array}\right) H 
         \left(\begin{array}{c}
	     x_1 \\ 
	     y_1
         \end{array}\right)
	 = 
	 G 
         \left(\begin{array}{c}
	     a \\ 
	     b
         \end{array}\right)
         \left(\begin{array}{c}
	     r \\ 
	     0
         \end{array}\right)
      @f]
      where @f$ G @f$ is a 2 by 2 Givens plane rotation matrix which
      annihilates @f$ b@f$, and where @f$ H@f$ us chosen for numerical
      stability and computational efficiency. 

      The function operator applies the modified Givens rotation to a
      pair of real vectors @f$ v, u@f$ each with @f$ n@f$ elements: 
      @f[
         \left(\begin{array}{c}
	     x_i \\ 
	     y_i
         \end{array}\right)
	 =
	 H
         \left(\begin{array}{c}
	     x_i \\ 
	     y_i
         \end{array}\right)
      @f]
      These vectors may be either rows or columns of matrices and the
      indexing of the vectors may be either forward or backwards. */
  template <>
  struct modified_givens_rotation<@type@> : public givens_rotation<@type@>
  {
  public:
    /** Value type */
    typedef @type@ value_type;
    /** Vector type */
    typedef vector<value_type> vector_type;
    /** Matrix type */
    typedef matrix<value_type> matrix_type;
    /** Matrix type */
    typedef matrix_type::trait_type trait_type;
    
    /** Generate the modified Givens rotation.  
	@param d1 On input, the first scale parameter, on output it is
	updated. 
	@param d2 On input, the second scale parameter, on output it is
	updated.  
	@param x0 First element of the first vector to make the
	rotation for 
	@param y0 First element of the second vector to make the
	rotation for 
	@return  */
    modified_givens_rotation(value_type& d1, 
			     value_type& d2, 
			     value_type& x0, 
			     value_type& y0)
    {
      int re = gsl_blas_@btype@rotmg(&d1, &d2, &x0, y0, _p);
      (void)re;
      long t = long(_p);
      switch (t) {
      case -2:
	matrix_type::operator()(0,0) = trait_type::unit();
	matrix_type::operator()(1,1) = trait_type::unit();
	matrix_type::operator()(0,1) = _p[3];
	matrix_type::operator()(1,0) = _p[2];
	break;
      case -1:
	matrix_type::operator()(0,0) = _p[1];
	matrix_type::operator()(0,1) = _p[3];
	matrix_type::operator()(1,0) = _p[2];
	matrix_type::operator()(1,1) = _p[4];
	break;
      case 0:
	matrix_type::operator()(0,0) = _p[1];
	matrix_type::operator()(0,1) = trait_type::unit();
	matrix_type::operator()(1,0) = -trait_type::unit();
	matrix_type::operator()(1,1) = _p[4];
	break;
      case 1:
	matrix_type::operator()(0,0) = trait_type::unit();
	matrix_type::operator()(1,1) = trait_type::unit();
	matrix_type::operator()(0,1) = trait_type::null();
	matrix_type::operator()(1,0) = trait_type::null();
	break;
      }
    }
    /** Apply the modified Givens rotation 
	@param v Vector to apply the rotation to 
	@param u Vector to apply the rotation to */
    void operator()(vector_type& v, vector_type& u) const
    {
      int re = gsl_blas_@btype@rotm(v._vector, u._vector, _p);
      (void)re;
    }
  protected:
    /** Hidden deault constructor */ 
    modified_givens_rotation() { for (size_t i= 0; i < 5; i++) _p[i] = 0; } 
    /** Array of entries encoding the matrix */
    @type@ _p[5];
  };
#endif

  //==================================================================
  // BLAS Level 2
  /** @defgroup blas_lvl2@name@ Specialised for @type@
      @ingroup blas_lvl2 
  */
  //__________________________________________________________________
  /** compute the matrix-vector product and sum 
      @f$ u = \alpha A v + \beta u@f$
      @ingroup matrix 
      @param alpha The matrix scalar @f$ \alpha@f$
      @param a The matrix @f$ A@f$
      @param v The vector @f$ v@f$
      @param beta The vector scalar @f$ \beta@f$
      @param u The vector @f$ u@f$, which is overwritten on output by
      the matrix-vector product. 
      @internal This is `tgemv'
  */
  template <>
  inline
  void 
  matrix_vector_product(const @type@&         alpha, 
			const matrix<@type@>& a, 
			const vector<@type@>& v,
			const @type@&         beta, 
			vector<@type@>&       u) 
  {
    int re = gsl_blas_@btype@gemv(CblasNoTrans, alpha, a._matrix, 
				  v._vector, beta, u._vector);
    (void)re;
  }
  /** compute the matrix-vector product and sum 
      @f$ u = \alpha A v + \beta u@f$
      @ingroup matrix 
      @param alpha The matrix scalar @f$ \alpha@f$
      @param a The matrix @f$ A@f$
      @param v The vector @f$ v@f$
      @param beta The vector scalar @f$ \beta@f$
      @param u The vector @f$ u@f$, which is overwritten on output by
      the matrix-vector product. 
      @internal This is `tgemv'
  */
  template <>
  inline
  void 
  matrix_vector_product(const @type@&               alpha, 
			const matrix_manip<@type@>  a, 
			const vector<@type@>&       v,
			const @type@&               beta, 
			vector<@type@>&             u) 
  {
    int re = 0;
    CBLAS_UPLO_t      al = CBLAS_UPLO_t(a._location);
    CBLAS_TRANSPOSE_t at = CBLAS_TRANSPOSE_t(a._transform);
    CBLAS_DIAG_t      ad = CBLAS_DIAG_t(a._diagonal);
    switch (a._type) {
    case inverse_triangular_type:
      {
	vector<@type@> tmp(v);
	re = gsl_blas_@btype@trsv(al, at, ad, a._matrix._matrix, tmp._vector);
	tmp *= alpha;
	u   *= beta;
	u   += tmp;
      }
      break;
    case triangular_type:
      {
	vector<@type@> tmp(v);
	re = gsl_blas_@btype@trmv(al, at, ad, a._matrix._matrix, tmp._vector);
	tmp *= alpha;
	u   *= beta;
	u   += tmp;
      }
      break;
#if @complex@ 
    case hermitian_type:
      re = gsl_blas_@btype@hemv(al, alpha, a._matrix._matrix, v._vector, beta, 
				u._vector);
      break;
#else
    case symmetric_type:
      re = gsl_blas_@btype@symv(al, alpha, a._matrix._matrix, v._vector, beta, 
				u._vector);
      break;      
#endif
    default:
      re = gsl_blas_@btype@gemv(at, alpha, a._matrix._matrix, v._vector, beta, 
				u._vector);
      break; 
    }
  }  

  //__________________________________________________________________
  /** compute the rank-1 update  @f$ A = \alpha v u^T + A @f$ or, if
      @a c is @c true and @f$ A@f$ is complex, @f$ A = \alpha v u^H + A
      @f$ of the matrix @f$ A@f$.
      @ingroup blas_lvl2@name@
      @param alpha The scalar @f$ \alpha@f$
      @param v The first vector @f$ v@f$
      @param u The second vector @f$ u@f$
      @param a The matrix @f$ A@f$ to update
      @param c Whether to conjugate the second vector
      @internal This is `ger', `gerc', `geru' */
  template <>
  inline
  void
  rank_1_update(const @type@& alpha, 
		const vector<@type@>& v, 
		const vector<@type@>& u,
		matrix<@type@>&       a, 
		bool                  c) 
  {
    int re;
#if @complex@
    if (c)
      re = gsl_blas_@btype@gerc(alpha, v._vector, u._vector, a._matrix);
    else 
      re = gsl_blas_@btype@geru(alpha, v._vector, u._vector, a._matrix);
#else
    (void)c;
    re = gsl_blas_@btype@ger(alpha, v._vector, u._vector, a._matrix);
#endif
  }
  /** compute the rank-1 update  @f$ A = \alpha v u^T + A @f$ or, if
      @a c is @c true and @f$ A@f$ is complex, @f$ A = \alpha v u^H + A
      @f$ of the matrix @f$ A@f$.
      @ingroup blas_lvl2@name@
      @param alpha The scalar @f$ \alpha@f$
      @param v The first vector @f$ v@f$
      @param u The second vector @f$ u@f$
      @param a The matrix @f$ A@f$ to update
      @param c Whether to conjugate the second vector
      @internal This is `ger', `gerc', `geru' */
  template <>
  inline
  void
  rank_1_update(const @type@& alpha, 
		const vector<@type@>& v, 
		const vector<@type@>& u,
		matrix_manip<@type@>  a, 
		bool                  c) 
  {
    int re;
    switch (a._type) {
#if @complex@
    case hermitian_type:
      re = gsl_blas_@btype@her(CBLAS_UPLO(a._location), 
			       alpha.real(), v._vector, a._matrix._matrix);
      break;
#else
    case symmetric_type:
      re = gsl_blas_@btype@syr(CBLAS_UPLO(a._location), 
			       alpha, v._vector, a._matrix._matrix);
      break;
#endif
    default:
#if @complex@
      if (c)
	re = gsl_blas_@btype@gerc(alpha,v._vector,u._vector,a._matrix._matrix);
      else 
	re = gsl_blas_@btype@geru(alpha,v._vector,u._vector,a._matrix._matrix);
#else
      re = gsl_blas_@btype@ger(alpha, v._vector, u._vector, a._matrix._matrix);
      (void)c;
#endif
      break;
    }
  }
  
  //__________________________________________________________________
  /** compute the symmetric rank-2 update  @f$ A = \alpha v u^T +
      \alpha u v^T @f$ or, if @f$ A@f$ is complex the hermitian rank-2
      update @f$ A = \alpha v u^H + \alpha u v^H @f$, of the matrix
      @f$ A@f$. 
      @ingroup blas_lvl2@name@
      @param alpha The scalar @f$ \alpha@f$
      @param v The first vector @f$ v@f$
      @param u The second vector @f$ u@f$ 
      @param a The matrix @f$ A@f$ to update
      @internal This is `syr2' or `her2' */
  template <>
  inline
  void
  rank_2_update(const @type@&         alpha, 
		const vector<@type@>& v, 
		const vector<@type@>& u, 
		matrix_manip<@type@>  a)
  {
    int re;
    switch (a._type) {
#if @complex@
    case hermitian_type:
      re = gsl_blas_@btype@her2(CBLAS_UPLO(a._location), alpha, v._vector,
				u._vector, a._matrix._matrix);
      break;
#else
    case symmetric_type:
      re = gsl_blas_@btype@syr2(CBLAS_UPLO(a._location), alpha, v._vector, 
				u._vector, a._matrix._matrix);
      break;
#endif
    default:
      break;
    }
  }
  
  //==================================================================
  // BLAS Level 3
  /** @defgroup blas_lvl3@name@ Specialised for @type@
      @ingroup blas_lvl3 
  */
  /** Compute the matrix-matrix product.  @f$ C = \alpha A B + \beta
      C@f$
      @ingroup matrix 
      @param alpha The constant @f$ \alpha@f$
      @param a The matrix @f$ A@f$
      @param b The matrix @f$ B@f$
      @param beta The constant @f$ \beta@f$
      @param c The matrix @f$ C@f$.  On return, this is overwritten by
      the product */
  template <> 
  inline 
  void 
  matrix_matrix_product(const @type@&         alpha, 
			const matrix<@type@>& a,
			const matrix<@type@>& b,
			const @type@&         beta,
			matrix<@type@>&       c) 
  {
    int re = 0;
    re = gsl_blas_@btype@gemm(CblasNoTrans, CblasNoTrans, alpha, a._matrix,
			      b._matrix, beta, c._matrix);
  }
  
  /** Compute the matrix-matrix product.  @f$ C = \alpha A B + \beta C@f$
      @ingroup matrix 
      @param alpha The constant @f$ \alpha@f$
      @param a The matrix @f$ A@f$
      @param b The matrix @f$ B@f$
      @param beta The constant @f$ \beta@f$
      @param c The matrix @f$ C@f$.  On return, this is overwritten by
      the product */
  template <> 
  inline 
  void 
  matrix_matrix_product(const @type@&               alpha, 
			const matrix_manip<@type@>  a,
			const matrix_manip<@type@>  b,
			const @type@&               beta,
			matrix<@type@>&             c)
  {
    int re;
    CBLAS_SIDE_t      as = CBLAS_SIDE_t(a._side);
    CBLAS_UPLO_t      al = CBLAS_UPLO_t(a._location);
    CBLAS_TRANSPOSE_t at = CBLAS_TRANSPOSE_t(a._transform);
    CBLAS_DIAG_t      ad = CBLAS_DIAG_t(a._diagonal);
    CBLAS_TRANSPOSE_t bt = CBLAS_TRANSPOSE_t(b._transform);
    switch (a._type) {
#if @complex@
#else
    case hermitian_type: 
#endif
    case symmetric_type: 
      // std::cout << "Doing symmm" << std::endl;
      re = gsl_blas_@btype@symm(as, al, alpha, a._matrix._matrix, 
				b._matrix._matrix, beta, c._matrix);
      break;
    case triangular_type: 
      {
	matrix<@type@> tmp(b._matrix);
	switch (b._transform) {
	case transpose_transform: tmp.transpose(); break;
#if @complex@
	case adjoint_transform:   
	  tmp.transpose();
	  tmp.conjugate();
	  // for (size_t i = 0; i < tmp.row_size(); i++) 
	  //  for (size_t j = 0; j < tmp.column_size(); j++) 
	  //    tmp(i,j) = tmp(i,j).conjugate();
#endif
	  break;
	default:
	  break;
	}
	// std::cout << "Doing trmm" << std::endl;
	re = gsl_blas_@btype@trmm(as, al, at, ad, alpha, a._matrix._matrix, 
				  tmp._matrix);
	if (c.is_null()) c = tmp;
	else { c *= beta; c += tmp; }
      }
      break;
    case inverse_triangular_type: 
      {
	// std::cout << "Doing trsmm" << std::endl;
	matrix<@type@> tmp(b._matrix);
	re = gsl_blas_@btype@trsm(as, al, at, ad, alpha, a._matrix._matrix, 
				  tmp._matrix);
	if (c.is_null()) c = tmp;
	else { c *= beta; c += tmp; }
      }
      break;
#if @complex@
    case hermitian_type: 
      // std::cout << "Doing hemm" << std::endl;
      re = gsl_blas_@btype@hemm(as, al, alpha, a._matrix._matrix, 
				b._matrix._matrix, beta, c._matrix);
      break;
#endif
    default:
      // std::cout << "Doing gemm" << std::endl;
      re = gsl_blas_@btype@gemm(at, bt, alpha, a._matrix._matrix,
				b._matrix._matrix, beta, c._matrix);
      break;
    }
  }
  /** Compute the matrix-matrix product.  @f$ C = \alpha A B + \beta C@f$
      @ingroup matrix
      @param alpha The constant @f$ \alpha@f$
      @param a The matrix @f$ A@f$
      @param b The matrix @f$ B@f$
      @param beta The constant @f$ \beta@f$
      @param c The matrix @f$ C@f$.  On return, this is overwritten by
      the product */
  template <> 
  inline 
  void 
  matrix_matrix_product(const @type@&               alpha, 
			const matrix_manip<@type@>  a,
			const matrix<@type@>&       b,
			const @type@&               beta,
			matrix<@type@>&             c)
  {
    return matrix_matrix_product(alpha, a, matrix_manip<@type@>(b), beta, c);
  }

  //__________________________________________________________________
  /** Compute the rank k update of the matrix 
      @f$ C = \alpha A A^T + \beta C@f$ 
      or  @f$ C = \alpha A A^H + \beta C@f$ if @a A is complex.
      If the transpose is requested, then 
      @f$ C = \alpha A^T A + \beta C@f$ or 
      @f$ C = \alpha A^H A + \beta C@f$ is computed
      Note, that the 
      input matrix @a A must be symmetric or hermitian. 
      @ingroup blas_lvl3@name@
      @param alpha The constant @f$ \alpha@f$
      @param a The matrix @f$ M@f$ 
      @param c The matrix @f$ C@f$ On return, this is overwritten by
      the update
      @param beta The constant @f$ \beta@f$ */
  template <> 
  inline 
  void 
  rank_k_update(const @type@&         alpha, 
		matrix<@type@>&       a,
		const @type@&         beta,
		const matrix<@type@>& c)
  {
    int re;
    re = gsl_blas_@btype@syrk(CblasUpper, CblasNoTrans, 
			      alpha, c._matrix, beta, a._matrix);
  }
  
  /** Compute the rank k update of the matrix 
      @f$ C = \alpha A A^T + \beta C@f$ 
      or  @f$ C = \alpha A A^H + \beta C@f$ if @a A is complex.
      If the transpose is requested, then 
      @f$ C = \alpha A^T A + \beta C@f$ or 
      @f$ C = \alpha A^H A + \beta C@f$ is computed
      Note, that the 
      input matrix @a A must be symmetric or hermitian. 
      @ingroup blas_lvl3@name@
      @param alpha The constant @f$ \alpha@f$
      @param a The matrix @f$ M@f$ 
      @param c The matrix @f$ C@f$ On return, this is overwritten by
      the update
      @param beta The constant @f$ \beta@f$ */
  template <> 
  inline 
  void 
  rank_k_update(const @type@&              alpha, 
		matrix_manip<@type@>       a,
		const @type@&              beta,
		const matrix_manip<@type@> c)
  {
    int re;
    switch (c._type) {
#if @complex@
    case hermitian_type: 
      re = gsl_blas_@btype@herk(CBLAS_UPLO_t(c._location), 
				CBLAS_TRANSPOSE_t(a._transform), 
				alpha.real(), a._matrix._matrix, 
				beta.real(), c._matrix._matrix);
      break;
#endif
    default:
      re = gsl_blas_@btype@syrk(CBLAS_UPLO_t(c._location), 
				CBLAS_TRANSPOSE_t(a._transform), 
				alpha, a._matrix._matrix, beta, 
				c._matrix._matrix);
      break;
    }
  }
  /** Compute the rank 2k update of the matrix @f$ O = \alpha (A B^T + B
      A^T) + \beta O@f$ or  @f$ O = \alpha (A B^H + B A^H) + \beta
      C@f$ if @f$ C@f$ is complex.  If the transpose is requested, then 
      @f$ C = \alpha (A^T B + B^T A) + \beta C@f$ or 
      @f$ C = \alpha (A^H B + B^H A) + \beta C@f$ is computed. 
      Note, that the input matrix @f$ C@f$ must
      be symmetric or hermitian.  
      @ingroup blas_lvl3@name@
      @param alpha The constant @f$ \alpha@f$
      @param a The matrix @f$ A@f$ 
      @param b The matrix @f$ B@f$
      @param beta The constant @f$ \beta@f$
      @param c The matrix @f$ C@f$. On return, this is overwritten by
      the update */
  template <> 
  inline 
  void 
  rank_2k_update(const @type@&         alpha, 
		 const matrix<@type@>& a,
		 const matrix<@type@>& b,
		 const @type@&         beta,
		 matrix<@type@>&       c)
  {
    int re;
    re = gsl_blas_@btype@syr2k(CblasUpper, CblasNoTrans, 
			       alpha, a._matrix, b._matrix, beta, 
			       c._matrix);
  }
  
  /** Compute the rank 2k update of the matrix @f$ O = \alpha (A B^T + B
      A^T) + \beta O@f$ or  @f$ O = \alpha (A B^H + B A^H) + \beta
      C@f$ if @f$ C@f$ is complex.  If the transpose is requested, then 
      @f$ C = \alpha (A^T B + B^T A) + \beta C@f$ or 
      @f$ C = \alpha (A^H B + B^H A) + \beta C@f$ is computed. 
      Note, that the input matrix @f$ C@f$ must
      be symmetric or hermitian.  
      @ingroup blas_lvl3@name@
      @param alpha The constant @f$ \alpha@f$
      @param a The matrix @f$ A@f$ 
      @param b The matrix @f$ B@f$
      @param beta The constant @f$ \beta@f$
      @param c The matrix @f$ C@f$. On return, this is overwritten by
      the update */
  template <> 
  inline 
  void 
  rank_2k_update(const @type@&               alpha, 
		 const matrix_manip<@type@>  a,
		 const matrix_manip<@type@>  b,
		 const @type@&               beta,
		 matrix_manip<@type@>        c)
  {
    int re;
    switch (c._type) {
#if @complex@
    case hermitian_type: 
      re = gsl_blas_@btype@her2k(CBLAS_UPLO_t(c._location), 
				 CBLAS_TRANSPOSE_t(a._transform), 
				 alpha, a._matrix._matrix, b._matrix._matrix, 
				 beta.real(), c._matrix._matrix);
      break;
#endif
    default: 
      re = gsl_blas_@btype@syr2k(CBLAS_UPLO_t(c._location), 
				 CBLAS_TRANSPOSE_t(a._transform), 
				 alpha, a._matrix._matrix, 
				 b._matrix._matrix, beta, c._matrix._matrix);
      break;
    }
  }
}

#endif
//____________________________________________________________________
//
// EOF
//


